<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Rey's Blog]]></title>
  <subtitle><![CDATA[<!-- A site to show something about myself -->]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://reygreen1.github.io/"/>
  <updated>2015-11-16T12:01:56.000Z</updated>
  <id>http://reygreen1.github.io/</id>
  
  <author>
    <name><![CDATA[guorui]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[[译]WebGL 基础系列：图像处理（续）]]></title>
    <link href="http://reygreen1.github.io/2015/11/16/webgl-image-processing-continued/"/>
    <id>http://reygreen1.github.io/2015/11/16/webgl-image-processing-continued/</id>
    <published>2015-11-15T16:00:00.000Z</published>
    <updated>2015-11-16T12:01:56.000Z</updated>
    <content type="html"><![CDATA[<p>原文地址：<a href="http://webglfundamentals.org/webgl/lessons/webgl-image-processing-continued.html" target="_blank" rel="external">http://webglfundamentals.org/webgl/lessons/webgl-image-processing-continued.html</a></p>
<p><img src="http://7tt058.com1.z0.glb.clouddn.com/El%20Capitan.jpg" alt="El Capitan"></p>
<blockquote>
<p>This article is a continuation of <a href="http://webglfundamentals.org/webgl/lessons/webgl-image-processing.html" target="_blank" rel="external">WebGL Image Processing</a>. If you haven’t read that I suggest <a href="http://webglfundamentals.org/webgl/lessons/webgl-image-processing.html" target="_blank" rel="external">you start there</a>.</p>
</blockquote>
<p>本文接上一篇<a href="http://reygreen1.github.io/2015/11/13/webgl-image-processing/" target="_blank" rel="external">WebGL 图像处理</a>的内容继续讨论。如果你还没有读过，那么我建议你先去了解下上一篇的内容。</p>
<blockquote>
<p>The next most obvious question for image processing is how to apply multiple effects?</p>
</blockquote>
<p>对于图像处理而言，另一个比较重要的问题是：如何同时添加多种处理效果？</p>
<a id="more"></a>
<blockquote>
<p>Well, you could try to generate shaders on the fly. Provide a UI that lets the user select the effects he wants to use then generate a shader that does all of the effects. That might not always be possible though that technique is often used to <a href="http://www.youtube.com/watch?v=cQUn0Zeh-0Q" target="_blank" rel="external">create effects for real time graphics</a>.</p>
</blockquote>
<p>当然，你可能会想要动态的来创建着色器。首先提供一个 UI 界面，让用户自己选择想要的效果，然后生成一个包含全部效果的着色器。这个技术不常用，但是在<a href="http://www.youtube.com/watch?v=cQUn0Zeh-0Q" target="_blank" rel="external">为实时图像创建效果</a>的时候经常使用。</p>
<blockquote>
<p>译者注：on the fly，这里应该是即时的、所见即所得的意思。我这里翻译成动态的，表示一边操作一边看到相应的着色器。</p>
</blockquote>
<hr>
<blockquote>
<p>A more flexible way is to use 2 more textures and render to each texture in turn, ping ponging back and forth and applying the next effect each time.</p>
</blockquote>
<p>这里有一种更加灵活的解决方案：使用多个纹理，然后在这几个纹理间进行多次处理后结果的存储，操作方式就像打乒乓球一样，来来回回，每次处理一个特殊效果。操作过程如下：</p>
<blockquote><br><pre>Original Image -&gt; [Blur]        -&gt; Texture 1<br>Texture 1      -&gt; [Sharpen]     -&gt; Texture 2<br>Texture 2      -&gt; [Edge Detect] -&gt; Texture 1<br>Texture 1      -&gt; [Blur]        -&gt; Texture 2<br>Texture 2      -&gt; [Normal]      -&gt; Canvas</pre><br></blockquote>

<blockquote>
<p>To do this we need to create framebuffers. In WebGL and OpenGL, a Framebuffer is actually a poor name. A WebGL/OpenGL Framebuffer is really just a collection of state and not actually a buffer of any kind. But, by attaching a texture to a framebuffer we can render into that texture. </p>
</blockquote>
<p>为了达到这样的目的，我们需要创建帧缓冲区（framebuffer）。在 WebGL 和 OpenGL 中，帧缓冲区是一个很“奇葩”的命名，它实际上只是一个状态集合，而并不是一个特定类型的缓冲区。但是，当你给它绑定一个纹理的时候，这个纹理就会被渲染出来。</p>
<blockquote>
<p>First let’s turn <a href="webgl-image-processing.html">the old texture creation code</a> into a function</p>
</blockquote>
<p>首先，让我们把<a href="http://reygreen1.github.io/2015/11/13/webgl-image-processing/" target="_blank" rel="external">旧的创建纹理的代码</a>封装到一个函数里：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAndSetupTexture</span><span class="params">(gl)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> texture = gl.createTexture();</span><br><span class="line">  gl.bindTexture(gl.TEXTURE_2D, texture);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置纹理参数，从而让我们可以渲染任何大小的图片，注意这些操作都是针对像素级的操作。</span></span><br><span class="line">  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);</span><br><span class="line">  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);</span><br><span class="line">  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);</span><br><span class="line">  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> texture;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建纹理并把图片放入纹理中</span></span><br><span class="line"><span class="keyword">var</span> originalImageTexture = createAndSetupTexture(gl);</span><br><span class="line">gl.texImage2D(gl.TEXTURE_2D, <span class="number">0</span>, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>And now let’s use that function to make 2 more textures and attach them to 2 framebuffers.</p>
</blockquote>
<p>那么现在我们就可以使用这个函数了。我们使用它来创建 2 个纹理并将它们同 2 个帧缓冲区联系起来。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 2 个纹理并把它们同帧缓冲区联系起来</span></span><br><span class="line"><span class="keyword">var</span> textures = [];</span><br><span class="line"><span class="keyword">var</span> framebuffers = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> ii = <span class="number">0</span>; ii &lt; <span class="number">2</span>; ++ii) &#123;</span><br><span class="line">  <span class="keyword">var</span> texture = createAndSetupTexture(gl);</span><br><span class="line">  textures.push(texture);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把纹理设置成图片的大小</span></span><br><span class="line">  gl.texImage2D(</span><br><span class="line">      gl.TEXTURE_2D, <span class="number">0</span>, gl.RGBA, image.width, image.height, <span class="number">0</span>,</span><br><span class="line">      gl.RGBA, gl.UNSIGNED_BYTE, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建一个帧缓冲区</span></span><br><span class="line">  <span class="keyword">var</span> fbo = gl.createFramebuffer();</span><br><span class="line">  framebuffers.push(fbo);</span><br><span class="line">  gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把纹理同帧缓冲区联系起来</span></span><br><span class="line">  gl.framebufferTexture2D(</span><br><span class="line">      gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Now let’s make a set of kernels and then a list of them to apply.</p>
</blockquote>
<p>现在，我们来创建一组核和一个需要用到的效果列表。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一些卷积核</span></span><br><span class="line"><span class="keyword">var</span> kernels = &#123;</span><br><span class="line">  normal: [</span><br><span class="line">    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">  ],</span><br><span class="line">  gaussianBlur: [</span><br><span class="line">    <span class="number">0.045</span>, <span class="number">0.122</span>, <span class="number">0.045</span>,</span><br><span class="line">    <span class="number">0.122</span>, <span class="number">0.332</span>, <span class="number">0.122</span>,</span><br><span class="line">    <span class="number">0.045</span>, <span class="number">0.122</span>, <span class="number">0.045</span></span><br><span class="line">  ],</span><br><span class="line">  unsharpen: [</span><br><span class="line">    -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>,</span><br><span class="line">    -<span class="number">1</span>,  <span class="number">9</span>, -<span class="number">1</span>,</span><br><span class="line">    -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span></span><br><span class="line">  ],</span><br><span class="line">  emboss: [</span><br><span class="line">     -<span class="number">2</span>, -<span class="number">1</span>,  <span class="number">0</span>,</span><br><span class="line">     -<span class="number">1</span>,  <span class="number">1</span>,  <span class="number">1</span>,</span><br><span class="line">      <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span></span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行的效果列表</span></span><br><span class="line"><span class="keyword">var</span> effectsToApply = [</span><br><span class="line">  <span class="string">"gaussianBlur"</span>,</span><br><span class="line">  <span class="string">"emboss"</span>,</span><br><span class="line">  <span class="string">"gaussianBlur"</span>,</span><br><span class="line">  <span class="string">"unsharpen"</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>And finally let’s apply each one, ping ponging which texture we are rendering too</p>
</blockquote>
<p>最后，我们会把这些效果全部应用起来。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从原图开始</span></span><br><span class="line">gl.bindTexture(gl.TEXTURE_2D, originalImageTexture);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制纹理的时候不需要对图片进行y轴翻转</span></span><br><span class="line">gl.uniform1f(flipYLocation, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历我们想使用的效果</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> ii = <span class="number">0</span>; ii &lt; effectsToApply.length; ++ii) &#123;</span><br><span class="line">  <span class="comment">// 设置要绘制到的帧缓冲区</span></span><br><span class="line">  setFramebuffer(framebuffers[ii % <span class="number">2</span>], image.width, image.height);</span><br><span class="line"></span><br><span class="line">  drawWithKernel(effectsToApply[ii]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下一次绘制时，使用刚刚渲染的纹理</span></span><br><span class="line">  gl.bindTexture(gl.TEXTURE_2D, textures[ii % <span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后将结果绘制到 canvas 上</span></span><br><span class="line">gl.uniform1f(flipYLocation, -<span class="number">1</span>);  <span class="comment">// 需要为 canvas 做y轴翻转</span></span><br><span class="line">setFramebuffer(<span class="literal">null</span>, canvas.width, canvas.height);</span><br><span class="line">drawWithKernel(<span class="string">"normal"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setFramebuffer</span><span class="params">(fbo, width, height)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 设置要渲染的帧缓冲区</span></span><br><span class="line">  gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 告诉着色器帧缓冲区的分辨率</span></span><br><span class="line">  gl.uniform2f(resolutionLocation, width, height);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置视图大小</span></span><br><span class="line">  gl.viewport(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawWithKernel</span><span class="params">(name)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 设置核</span></span><br><span class="line">  gl.uniform1fv(kernelLocation, kernels[name]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 绘制矩形</span></span><br><span class="line">  gl.drawArrays(gl.TRIANGLES, <span class="number">0</span>, <span class="number">6</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Here’s a working version with a slightly more flexible UI. Check the effects to turn them on. Drag the effects to reorder how they are applied.</p>
</blockquote>
<p>下面是一个可运行的例子，你可以看下它最终的显示效果，也可以改变各个效果的执行顺序。</p>
<iframe class="webgl_example" style="width: 400px; height: 340px;" src="http://webglfundamentals.org/webgl/webgl-2d-image-processing.html"></iframe>

<p>你可以在<a href="http://webglfundamentals.org/webgl/webgl-2d-image-processing.html" target="_blank" rel="external">新窗口</a>打开这个实例。</p>
<blockquote>
<p>Some things I should go over.  </p>
</blockquote>
<p>我们来回顾下上面的代码。</p>
<p>Calling <code>gl.bindFramebuffer</code> with <code>null</code> tells WebGL you want to render to the canvas instead of to one of your framebuffers.</p>
<p>调用 <code>gl.bindFramebuffer</code> 时，如果使用 <code>null</code> 作为参数，这实际上是告诉 WebGL 你想要渲染到 canvas 而不是帧缓冲区中。</p>
<blockquote>
<p>WebGL has to convert from <a href="http://webglfundamentals.org/webgl/lessons/webgl-fundamentals.html" target="_blank" rel="external">clipspace</a> back into pixels. It does this based on the settings of <code>gl.viewport</code>. The settings of <code>gl.viewport</code> default to the size of the canvas when we initialize WebGL. Since the framebuffers we are rendering into are a different size than the canvas we need to set the viewport appropriately.</p>
</blockquote>
<p>WebGL 需要将<a href="http://reygreen1.github.io/2015/10/24/webgl-fundamentals/" target="_blank" rel="external">剪切空间</a>转换为像素。这种转换依赖 <code>gl.viewport</code> 的设置。默认情况下，可以设置为初始化 WebGL 时 canvas 的大小。但是帧缓冲区的大小并不一致，因此我们需要合理设置下 viewport。</p>
<p>Finally in the <a href="http://webglfundamentals.org/webgl/lessons/webgl-fundamentals.html" target="_blank" rel="external">original example</a> we flipped the Y coordinate when rendering because WebGL displays the canvas with 0,0 being the bottom left corner instead of the more traditional for 2D top left. That’s not needed when rendering to a framebuffer. Because the framebuffer is never displayed, which part is top and bottom is irrelevant. All that matters is that pixel 0,0 in the framebuffer corresponds to 0,0 in our calculations. To deal with this I made it possible to set whether to flip or not by adding one more input into the shader.</p>
<p>最后要说的是，在<a href="http://reygreen1.github.io/2015/10/24/webgl-fundamentals/" target="_blank" rel="external">最开始的例子</a>中，在渲染的时候需要翻转下 y 轴坐标，这是因为 WebGL 纹理坐标系统把左下角作为坐标原点，而不是像图片坐标系统那样把左上角作为坐标原点。但是在渲染到帧缓冲区时，不需要这么做。这是因为，帧缓冲区从来都不会被显示出来，哪个地方是坐标原点其实是无关紧要的。有关系的地方在于，帧缓冲区里的坐标原点的像素需要匹配到我们计算出的原点。为了解决这个问题，可以通过多添加一个输入参数来决定是否需要进行翻转操作。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script id=<span class="string">"2d-vertex-shader"</span> type=<span class="string">"x-shader/x-vertex"</span>&gt;</span><br><span class="line">...</span><br><span class="line">uniform float u_flipY;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">   ...</span><br><span class="line">   gl_Position = vec4(clipSpace * vec2(<span class="number">1</span>, u_flipY), <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>And then we can set it when we render with</p>
</blockquote>
<p>然后我们就可以通过设置它来达到目的了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">var</span> flipYLocation = gl.getUniformLocation(program, <span class="string">"u_flipY"</span>);</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 不翻转</span></span><br><span class="line">gl.uniform1f(flipYLocation, <span class="number">1</span>);</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 翻转</span></span><br><span class="line">gl.uniform1f(flipYLocation, -<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>I kept this example simple by using a single GLSL program that can achieve multiple effects. If you wanted to do full on image processing you’d probably need many GLSL programs. A program for hue, saturation and luminance adjustment. Another for brightness and contrast. One for inverting, another for adjusting levels, etc. You’d need to change the code to switch GLSL programs and update the parameters for that particular program. I’d considered writing that example but it’s an exercise best left to the reader because multiple GLSL programs each with their own parameter needs probably means some major refactoring to keep it all from becoming a big mess of spaghetti. </p>
</blockquote>
<p>为了让实例看起来比较简单，我在这里只使用了一个 GLSL 程序来达到使用多种效果的目的。如果你要进行更全面的图像处理，那么可能需要多个 GLSL 程序。例如，一个程序用来控制色调、饱和度和控制亮度，另一个用来控制亮度和对比度。或者，一个程序用来控制反相，另一个用来调整程度。你需要修改代码来切换 GLSL 程序并为制定的程序更新相应参数。我原来也想要写个这样的例子，但是后来认为这是一个很好的练习题，所以留给读者自己来完成了。需要注意，多个程序意味着需要进行重构从而避免让代码成为一堆杂乱无章的代码。</p>
<blockquote>
<p>I hope this and the preceding examples have made WebGL seem a little more approachable and I hope starting with 2D helps make WebGL a little easier to understand. If I find the time I’ll try to write <a href="webgl-2d-translation.html">a few more articles</a> about how to do 3D as well as more details on what WebGL is really doing under the hood.<br>For a next step consider learning <a href="http://webglfundamentals.org/webgl/lessons/webgl-2-textures.html" target="_blank" rel="external">how to use 2 or more textures</a>.</p>
</blockquote>
<p>我希望上面的这些例子能让 WebGL 看起来更加“平易近人”。我认为以 2D 操作作为开始能让 WebGL 更容易理解。如果有时间的话，我也会写一些文章来讨论 3D 以及 WebGL 内部执行的细节。接下来可以考虑去学习下<br><a href="http://webglfundamentals.org/webgl/lessons/webgl-2-textures.html" target="_blank" rel="external">如何使用多个纹理</a>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文地址：<a href="http://webglfundamentals.org/webgl/lessons/webgl-image-processing-continued.html">http://webglfundamentals.org/webgl/lessons/webgl-image-processing-continued.html</a></p>
<p><img src="http://7tt058.com1.z0.glb.clouddn.com/El%20Capitan.jpg" alt="El Capitan"></p>
<blockquote>
<p>This article is a continuation of <a href="http://webglfundamentals.org/webgl/lessons/webgl-image-processing.html">WebGL Image Processing</a>. If you haven’t read that I suggest <a href="http://webglfundamentals.org/webgl/lessons/webgl-image-processing.html">you start there</a>.</p>
</blockquote>
<p>本文接上一篇<a href="http://reygreen1.github.io/2015/11/13/webgl-image-processing/">WebGL 图像处理</a>的内容继续讨论。如果你还没有读过，那么我建议你先去了解下上一篇的内容。</p>
<blockquote>
<p>The next most obvious question for image processing is how to apply multiple effects?</p>
</blockquote>
<p>对于图像处理而言，另一个比较重要的问题是：如何同时添加多种处理效果？</p>]]>
    
    </summary>
    
      <category term="webgl" scheme="http://reygreen1.github.io/tags/webgl/"/>
    
      <category term="webgl" scheme="http://reygreen1.github.io/categories/webgl/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]WebGL 基础系列：图像处理]]></title>
    <link href="http://reygreen1.github.io/2015/11/13/webgl-image-processing/"/>
    <id>http://reygreen1.github.io/2015/11/13/webgl-image-processing/</id>
    <published>2015-11-12T16:00:00.000Z</published>
    <updated>2015-11-16T11:56:56.000Z</updated>
    <content type="html"><![CDATA[<p>原文地址：<a href="http://webglfundamentals.org/webgl/lessons/webgl-image-processing.html" target="_blank" rel="external">http://webglfundamentals.org/webgl/lessons/webgl-image-processing.html</a></p>
<p><img src="http://7tt058.com1.z0.glb.clouddn.com/优胜美地.jpg" alt="优胜美地"></p>
<blockquote>
<p>Image processing is easy in WebGL. How easy? Read below.</p>
</blockquote>
<p>在 WebGL 中进行图像处理非常简单。有多简单？请接着往下看。</p>
<blockquote>
<p>This is a continuation from <a href="http://webglfundamentals.org/webgl/lessons/webgl-fundamentals.html" target="_blank" rel="external">WebGL Fundamentals</a>. If you haven’t read that I’d suggest <a href="http://webglfundamentals.org/webgl/lessons/webgl-fundamentals.html" target="_blank" rel="external">webgl-fundamentals.html</a> going there first.</p>
</blockquote>
<p>本文接<a href="http://webglfundamentals.org/webgl/lessons/webgl-fundamentals.html" target="_blank" rel="external">WebGL 基本原理</a>的内容进行描述。如果还没有读过，那么你最好先去看下<a href="http://webglfundamentals.org/webgl/lessons/webgl-fundamentals.html" target="_blank" rel="external">WebGL 基本原理</a>相关内容。</p>
<a id="more"></a>
<blockquote>
<p>To draw images in WebGL we need to use textures. Similarly to the way WebGL expects clipspace coordinates when rendering instead of pixels, WebGL expects texture coordinates when reading a texture. Texture coordinates go from 0.0 to 1.0 no matter the dimensions of the texture.</p>
</blockquote>
<p>我们需要使用纹理在 WebGL 中绘制图像。WebGL 在渲染时使用的是裁剪空间坐标，同样道理，它在读取纹理的时候使用的是纹理坐标。无论纹理尺寸多大，纹理坐标的范围都是从 0.0 到 1.0。</p>
<blockquote>
<p>Since we are only drawing a single rectangle (well, 2 triangles) we need to tell WebGL which place in the texture each point in the rectangle corresponds to. We’ll pass this information from the vertex shader to the fragment shader using a special kind of variable called a ‘varying’. It’s called a varying because it varies. WebGL will interpolate the values we provide in the vertex shader as it draws each pixel using the fragment shader.</p>
</blockquote>
<p>当我们在绘制一个矩形（恩，需要两个三角形来构成）的时候，我们需要将矩形上每个点对应的纹理位置信息提供给 WebGL。这时，需要使用一种特殊的变量来将这些信息从顶点着色器传递到片元着色器。这个特殊的变量就是 ‘varying’，它之所以这么命名就是因为它本身是变化的。当 WebGL 使用片元着色器来绘制像素时，它需要对顶点着色器提供的信息进行内插计算，从而得到正确的值来完成绘制。</p>
<blockquote>
<p>译者注：WebGL 会将顶点着色器和片元着色器中的同名 varying 变量建立一种“特殊”的连接，通过对顶点着色器中的 varying 变量进行内插计算得到结果，并提供给片元着色器中的同名 varying 变量。</p>
</blockquote>
<hr>
<blockquote>
<p>Using <a href="http://webglfundamentals.org/webgl/lessons/webgl-fundamentals.html" target="_blank" rel="external">the vertex shader from the end of the previous post</a> we need to add an attribute to pass in texture coordinates and then pass those on to the fragment shader.</p>
</blockquote>
<p>这里我们依然使用前面文章中提到的顶点着色器代码，但是我们需要额外添加一个 attribute 变量，用来将纹理坐标提供给片元着色器。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">attribute vec2 a_texCoord;</span><br><span class="line">...</span><br><span class="line">varying vec2 v_texCoord;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">// 将纹理坐标传递给片元着色器</span></span><br><span class="line">   <span class="comment">// GPU 会在这些值之间做内插计算</span></span><br><span class="line">   v_texCoord = a_texCoord;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Then we supply a fragment shader to look up colors from the texture.</p>
</blockquote>
<p>然后，我们就可以使用下面的片元着色器代码，从纹理中查找指定位置的颜色了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script id=<span class="string">"2d-fragment-shader"</span> type=<span class="string">"x-shader/x-fragment"</span>&gt;</span><br><span class="line">precision mediump float;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们的纹理</span></span><br><span class="line">uniform sampler2D u_image;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从顶点着色器传递过来的纹理坐标</span></span><br><span class="line">varying vec2 v_texCoord;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">   <span class="comment">// 在纹理中查找颜色值</span></span><br><span class="line">   gl_FragColor = texture2D(u_image, v_texCoord);</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Finally we need to load an image, create a texture and copy the image into the texture. Because we are in a browser images load asynchronously so we have to re-arrange our code a little to wait for the texture to load. Once it loads we’ll draw it.</p>
</blockquote>
<p>最后我们还需要加载图片、创建纹理，并把图片放入纹理中。因为浏览器中的图片是异步加载的，所以我们还需要对代码重新组织下。纹理加载完毕后我们就可以进行绘制了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> image = <span class="keyword">new</span> Image();</span><br><span class="line">  image.src = <span class="string">"http://someimage/on/our/server"</span>;  <span class="comment">// 必须要同域!!!</span></span><br><span class="line">  image.onload = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    render(image);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span><span class="params">(image)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 省略了前文出现过的一些代码</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 获取 attribute 变量的存储位置</span></span><br><span class="line">  <span class="keyword">var</span> texCoordLocation = gl.getAttribLocation(program, <span class="string">"a_texCoord"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为矩形提供纹理坐标</span></span><br><span class="line">  <span class="keyword">var</span> texCoordBuffer = gl.createBuffer();</span><br><span class="line">  gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);</span><br><span class="line">  gl.bufferData(gl.ARRAY_BUFFER, <span class="keyword">new</span> <span class="built_in">Float32Array</span>([</span><br><span class="line">      <span class="number">0.0</span>,  <span class="number">0.0</span>,</span><br><span class="line">      <span class="number">1.0</span>,  <span class="number">0.0</span>,</span><br><span class="line">      <span class="number">0.0</span>,  <span class="number">1.0</span>,</span><br><span class="line">      <span class="number">0.0</span>,  <span class="number">1.0</span>,</span><br><span class="line">      <span class="number">1.0</span>,  <span class="number">0.0</span>,</span><br><span class="line">      <span class="number">1.0</span>,  <span class="number">1.0</span>]), gl.STATIC_DRAW);</span><br><span class="line">  gl.enableVertexAttribArray(texCoordLocation);</span><br><span class="line">  gl.vertexAttribPointer(texCoordLocation, <span class="number">2</span>, gl.FLOAT, <span class="literal">false</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建纹理</span></span><br><span class="line">  <span class="keyword">var</span> texture = gl.createTexture();</span><br><span class="line">  gl.bindTexture(gl.TEXTURE_2D, texture);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置一些参数从而让我们可以处理任何大小的图片</span></span><br><span class="line">  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);</span><br><span class="line">  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);</span><br><span class="line">  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);</span><br><span class="line">  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将图片上传到纹理中</span></span><br><span class="line">  gl.texImage2D(gl.TEXTURE_2D, <span class="number">0</span>, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>And here’s the image rendered in WebGL.</p>
</blockquote>
<p>下面是一个 WebGL 渲染图片的例子：</p>
<iframe class="webgl_example" style="width: 400px; height: 300px;" src="http://webglfundamentals.org/webgl/webgl-2d-image.html"></iframe>

<p>你可以在<a href="http://webglfundamentals.org/webgl/webgl-2d-image.html" target="_blank" rel="external">新窗口</a>打开这个例子。</p>
<blockquote>
<p>Not too exciting so let’s manipulate that image. How about just swapping red and blue?</p>
</blockquote>
<p>是不是觉得上面的例子挺无聊的？好，那我们接下来做些处理，让事情变得有趣起来。你觉得我们将红色和蓝色交换下会发生什么事情？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">gl_FragColor = texture2D(u_image, v_texCoord).bgra;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>And now red and blue are swapped.</p>
</blockquote>
<p>现在红色和蓝色交换了，效果如下：</p>
<iframe class="webgl_example" style="width: 400px; height: 300px;" src="http://webglfundamentals.org/webgl/webgl-2d-image-red2blue.html"></iframe>

<p>你可以在<a href="http://webglfundamentals.org/webgl/webgl-2d-image-red2blue.html" target="_blank" rel="external">新窗口</a>打开这个例子。</p>
<blockquote>
<p>What if we want to do image processing that actually looks at other pixels? Since WebGL references textures in texture coordinates which go from 0.0 to 1.0 then we can calculate how much to move for 1 pixel with the simple math <code>onePixel = 1.0 / textureSize</code>.</p>
</blockquote>
<p>如果在图像处理的过程中需要参考其他像素该如何操作呢？因为 WebGL 处理纹理使用的是纹理坐标（范围[0.0,1.0]），所以我们可以通过计算来得到 WebGL 绘制一个像素所需要移动的距离，公式如下：</p>
<figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">onePixel </span>=<span class="string"> 1.0 / textureSize</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Here’s a fragment shader that averages the left and right pixels of each pixel in the texture.</p>
</blockquote>
<p>在下面的例子中，片元着色器对纹理中的每个像素做了处理，通过对当前像素、左边相邻像素、右边相邻像素求平均来获取当前像素颜色值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;script id=<span class="string">"2d-fragment-shader"</span> type=<span class="string">"x-shader/x-fragment"</span>&gt;</span><br><span class="line">precision mediump float;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 纹理</span></span><br><span class="line">uniform sampler2D u_image;</span><br><span class="line">uniform vec2 u_textureSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从顶点着色器传递过来的纹理坐标</span></span><br><span class="line">varying vec2 v_texCoord;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">   <span class="comment">// 计算纹理坐标中的 1 像素</span></span><br><span class="line">   vec2 onePixel = vec2(<span class="number">1.0</span>, <span class="number">1.0</span>) / u_textureSize;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 对左、中、右三个像素求平均值</span></span><br><span class="line">   gl_FragColor = (</span><br><span class="line">       texture2D(u_image, v_texCoord) +</span><br><span class="line">       texture2D(u_image, v_texCoord + vec2(onePixel.x, <span class="number">0.0</span>)) +</span><br><span class="line">       texture2D(u_image, v_texCoord + vec2(-onePixel.x, <span class="number">0.0</span>))) / <span class="number">3.0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>We then need to pass in the size of the texture from JavaScript.</p>
</blockquote>
<p>然后，我们需要通过 JavaScript 将纹理大小传递进去。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">var</span> textureSizeLocation = gl.getUniformLocation(program, <span class="string">"u_textureSize"</span>);</span><br><span class="line">...</span><br><span class="line"><span class="comment">// set the size of the image</span></span><br><span class="line">gl.uniform2f(textureSizeLocation, image.width, image.height);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Compare to the un-blurred image above.</p>
</blockquote>
<p>效果如下，可以同上面未进行模糊处理的图片对比下。</p>
<iframe class="webgl_example" style="width: 400px; height: 300px;" src="http://webglfundamentals.org/webgl/webgl-2d-image-blend.html"></iframe>

<p>你可以在<a href="http://webglfundamentals.org/webgl/webgl-2d-image-blend.html" target="_blank" rel="external">新窗口</a>打开这个例子。</p>
<blockquote>
<p>Now that we know how to reference other pixels let’s use a convolution kernel to do a bunch of common image processing. In this case we’ll use a 3x3 kernel. A convolution kernel is just a 3x3 matrix where each entry in the matrix represents how much to multiply the 8 pixels around the pixel we are rendering. We then divide the result by the weight of the kernel <a href="the sum of all values in the kernel">Here’s a pretty good article on it</a> or 1.0, whichever is greater. (<a href="http://docs.gimp.org/en/plug-in-convmatrix.html" target="_blank" rel="external">http://docs.gimp.org/en/plug-in-convmatrix.html</a>). And <a href="http://www.codeproject.com/KB/graphics/ImageConvolution.aspx" target="_blank" rel="external">here’s another article showing some actual code if you were to write this by hand in C++</a>.</p>
</blockquote>
<p>现在我们已经了解了如何获取其他像素信息，接下来我们将使用一个卷积核（convolution kernel）来做一些更通用的图像处理。在下面的例子中，我们将使用一个 3x3 的核。这里使用的卷积核是一个 3x3 的矩阵，里面的每一个元素的值将会与当前元素周围对应的 8 个像素值相乘。然后，我们将结果除以核的权重（核中所有值的总和）或 1.0。<a href="http://docs.gimp.org/en/plug-in-convmatrix.html" target="_blank" rel="external">这篇文章</a>很好的介绍了相关内容。<a href="http://www.codeproject.com/KB/graphics/ImageConvolution.aspx" target="_blank" rel="external">另一篇文章</a>介绍了一些具体的代码（C++ 写的）。</p>
<blockquote>
<p>In our case we’re going to do that work in the shader so here’s the new fragment shader.</p>
</blockquote>
<p>在例子中，我们准备在着色器中进行上面的操作。新的片元着色器代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;script id=<span class="string">"2d-fragment-shader"</span> type=<span class="string">"x-shader/x-fragment"</span>&gt;</span><br><span class="line">precision mediump float;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 纹理</span></span><br><span class="line">uniform sampler2D u_image;</span><br><span class="line">uniform vec2 u_textureSize;</span><br><span class="line">uniform float u_kernel[<span class="number">9</span>];</span><br><span class="line">uniform float u_kernelWeight;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顶点着色器传递来的纹理坐标信息</span></span><br><span class="line">varying vec2 v_texCoord;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">   vec2 onePixel = vec2(<span class="number">1.0</span>, <span class="number">1.0</span>) / u_textureSize;</span><br><span class="line">   vec4 colorSum =</span><br><span class="line">     texture2D(u_image, v_texCoord + onePixel * vec2(-<span class="number">1</span>, -<span class="number">1</span>)) * u_kernel[<span class="number">0</span>] +</span><br><span class="line">     texture2D(u_image, v_texCoord + onePixel * vec2( <span class="number">0</span>, -<span class="number">1</span>)) * u_kernel[<span class="number">1</span>] +</span><br><span class="line">     texture2D(u_image, v_texCoord + onePixel * vec2( <span class="number">1</span>, -<span class="number">1</span>)) * u_kernel[<span class="number">2</span>] +</span><br><span class="line">     texture2D(u_image, v_texCoord + onePixel * vec2(-<span class="number">1</span>,  <span class="number">0</span>)) * u_kernel[<span class="number">3</span>] +</span><br><span class="line">     texture2D(u_image, v_texCoord + onePixel * vec2( <span class="number">0</span>,  <span class="number">0</span>)) * u_kernel[<span class="number">4</span>] +</span><br><span class="line">     texture2D(u_image, v_texCoord + onePixel * vec2( <span class="number">1</span>,  <span class="number">0</span>)) * u_kernel[<span class="number">5</span>] +</span><br><span class="line">     texture2D(u_image, v_texCoord + onePixel * vec2(-<span class="number">1</span>,  <span class="number">1</span>)) * u_kernel[<span class="number">6</span>] +</span><br><span class="line">     texture2D(u_image, v_texCoord + onePixel * vec2( <span class="number">0</span>,  <span class="number">1</span>)) * u_kernel[<span class="number">7</span>] +</span><br><span class="line">     texture2D(u_image, v_texCoord + onePixel * vec2( <span class="number">1</span>,  <span class="number">1</span>)) * u_kernel[<span class="number">8</span>] ;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 将总和除以权重，但是只处理 rgb 值</span></span><br><span class="line">   <span class="comment">// 将 alpha 设置为 1.0</span></span><br><span class="line">   gl_FragColor = vec4((colorSum / u_kernelWeight).rgb, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>In JavaScript we need to supply a convolution kernel and its weight</p>
</blockquote>
<p>在 JavaScript 中，我们需要提供卷积核和它的权重。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">computeKernelWeight</span><span class="params">(kernel)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> weight = kernel.reduce(<span class="function"><span class="keyword">function</span><span class="params">(prev, curr)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> prev + curr;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> weight &lt;= <span class="number">0</span> ? <span class="number">1</span> : weight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="keyword">var</span> kernelLocation = gl.getUniformLocation(program, <span class="string">"u_kernel[0]"</span>);</span><br><span class="line"><span class="keyword">var</span> kernelWeightLocation = gl.getUniformLocation(program, <span class="string">"u_kernelWeight"</span>);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">var</span> edgeDetectKernel = [</span><br><span class="line">    -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>,</span><br><span class="line">    -<span class="number">1</span>,  <span class="number">8</span>, -<span class="number">1</span>,</span><br><span class="line">    -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span></span><br><span class="line">];</span><br><span class="line">gl.uniform1fv(kernelLocation, edgeDetectKernel);</span><br><span class="line">gl.uniform1f(kernelWeightLocation, computeKernelWeight(edgeDetectKernel));</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>And voila… Use the drop down list to select different kernels.</p>
</blockquote>
<p>好，大功告成！示例如下，可以在下拉菜单中选择不同的核来试试效果。</p>
<iframe class="webgl_example" style="width: 400px; height: 300px;" src="http://webglfundamentals.org/webgl/webgl-2d-image-3x3-convolution.html"></iframe>

<p>你可以在<a href="http://webglfundamentals.org/webgl/webgl-2d-image-3x3-convolution.html" target="_blank" rel="external">新窗口</a>打开这个例子。</p>
<blockquote>
<p>I hope this article has convinced you image processing in WebGL is pretty simple. Next up I’ll go over  <a href="http://webglfundamentals.org/webgl/lessons/webgl-image-processing-continued.html" target="_blank" rel="external">how to apply more than one effect to the image</a>.</p>
</blockquote>
<p>我希望通过这篇文章可以让你明白：在 WebGL 中处理图像非常简单。下一章我将介绍<a href="http://webglfundamentals.org/webgl/lessons/webgl-image-processing-continued.html" target="_blank" rel="external">如何在图片上应用多种效果</a>。</p>
<hr>
<h2 id="你问我答环节">你问我答环节</h2><blockquote>
<h3 id="‘u_image’_is_never_set-_How_does_that_work?">‘u_image’ is never set. How does that work?</h3></blockquote>
<h3 id="1-_u_image_一直没赋值，那它是如何工作的呢？">1. <code>u_image</code> 一直没赋值，那它是如何工作的呢？</h3><blockquote>
<p>Uniforms default to 0 so u_image defaults to using texture unit 0. Texture unit 0 is also the default active texture so calling bindTexture will bind the texture to texture unit 0.</p>
</blockquote>
<p>uniform 变量默认值为 0，所以与之类似，u_image 默认使用索引值为 0 的纹理单元。它同时也是默认激活的纹理，因此当调用 bindTexture 时，会把纹理绑定到该纹理单元。</p>
<blockquote>
<p>WebGL has an array of texture units. Which texture unit each sampler uniform references is set by looking up the location of that sampler uniform and then setting the index of the texture unit you want it to reference.</p>
</blockquote>
<p>WebGL 有一组纹理单元。需要通过查找 uniform 变量位置、设置纹理单元索引值的操作来将纹理传递给着色器中的取样器变量。</p>
<blockquote>
<p>For example:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> textureUnitIndex = <span class="number">6</span>; <span class="comment">// 使用 6 号纹理单元</span></span><br><span class="line"><span class="keyword">var</span> u_imageLoc = gl.getUniformLocation(</span><br><span class="line">    program, <span class="string">"u_image"</span>);</span><br><span class="line">gl.uniform1i(u_imageLoc, textureUnitIndex);</span><br></pre></td></tr></table></figure></p>
<p>To set textures on different units you call gl.activeTexture and then bind the texture you want on that unit. Example</p>
</blockquote>
<p>如果要在不同单元上设置纹理，需要调用 gl.activeTexture ，然后再将纹理绑定到你期望的单元上。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 someTexture 绑定到 6 号纹理单元</span></span><br><span class="line">gl.activeTexture(gl.TEXTURE6);</span><br><span class="line">gl.bindTexture(gl.TEXTURE_2D, someTexture);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>This works too</p>
</blockquote>
<p>下面的代码有同样的效果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> textureUnitIndex = <span class="number">6</span>; <span class="comment">// 使用 6 号纹理单元</span></span><br><span class="line"><span class="comment">// 将 someTexture 绑定到 6 号纹理单元</span></span><br><span class="line">gl.activeTexture(gl.TEXTURE0 + textureUnitIndex);</span><br><span class="line">gl.bindTexture(gl.TEXTURE_2D, someTexture);</span><br></pre></td></tr></table></figure>
<blockquote>
<h3 id="What’s_with_the_a,_u,_and_v__prefixes_in_from_of_variables_in_GLSL?">What’s with the a<em>, u</em>, and v_ prefixes in from of variables in GLSL?</h3></blockquote>
<h3 id="2-_为什么_GLSL_中的变量都要添加形如_a_、u__和_v__的前缀呢？">2. 为什么 GLSL 中的变量都要添加形如 <code>a_</code>、<code>u_</code> 和 <code>v_</code> 的前缀呢？</h3><blockquote>
<p>That’s just a naming convention. They are not required but for me it makes it easier to see at a glance<br>where the values are coming from. a<em> for attributes which is the data provided by buffers. u</em> for uniforms which are inputs to the shaders, v_ for varyings which are values passed from a vertex shader to a fragment shader and interpolated (or varied) between the vertices for each pixel drawn.<br>See <a href="webgl-how-it-works.html">How it works</a> for more details.</p>
</blockquote>
<p>这只是一种命名的规范而已。它不是强制性的规定，但是这么做可以让我们轻松识别该变量的来源。例如，<code>a_</code> 前缀的是 attribute 变量，由缓存对象提供变量值。<code>u_</code> 前缀的是 uniform 变量，包含了着色器的输入信息。<code>v_</code> 前缀的是 varying 变量，表示该变量值从顶点着色器传递给片元着色器，并在像素的绘制中需要进行内插运算。</p>
<p>可以在<a href="http://reygreen1.github.io/2015/10/25/webgl-how-it-works/" target="_blank" rel="external">WebGL 工作机制</a>中查看详细介绍。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文地址：<a href="http://webglfundamentals.org/webgl/lessons/webgl-image-processing.html">http://webglfundamentals.org/webgl/lessons/webgl-image-processing.html</a></p>
<p><img src="http://7tt058.com1.z0.glb.clouddn.com/优胜美地.jpg" alt="优胜美地"></p>
<blockquote>
<p>Image processing is easy in WebGL. How easy? Read below.</p>
</blockquote>
<p>在 WebGL 中进行图像处理非常简单。有多简单？请接着往下看。</p>
<blockquote>
<p>This is a continuation from <a href="http://webglfundamentals.org/webgl/lessons/webgl-fundamentals.html">WebGL Fundamentals</a>. If you haven’t read that I’d suggest <a href="http://webglfundamentals.org/webgl/lessons/webgl-fundamentals.html">webgl-fundamentals.html</a> going there first</a>.</p>
</blockquote>
<p>本文接<a href="http://webglfundamentals.org/webgl/lessons/webgl-fundamentals.html">WebGL 基本原理</a>的内容进行描述。如果还没有读过，那么你最好先去看下<a href="http://webglfundamentals.org/webgl/lessons/webgl-fundamentals.html">WebGL 基本原理</a>相关内容。</p>]]>
    
    </summary>
    
      <category term="webgl" scheme="http://reygreen1.github.io/tags/webgl/"/>
    
      <category term="webgl" scheme="http://reygreen1.github.io/categories/webgl/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]WebGL 基础系列：WebGL着色器和GLSL]]></title>
    <link href="http://reygreen1.github.io/2015/11/01/webgl-shaders-and-glsl/"/>
    <id>http://reygreen1.github.io/2015/11/01/webgl-shaders-and-glsl/</id>
    <published>2015-10-31T16:00:00.000Z</published>
    <updated>2015-11-03T03:33:46.000Z</updated>
    <content type="html"><![CDATA[<p>原文地址：<a href="http://webglfundamentals.org/webgl/lessons/webgl-shaders-and-glsl.html" target="_blank" rel="external">http://webglfundamentals.org/webgl/lessons/webgl-shaders-and-glsl.html</a></p>
<p><img src="http://7tt058.com1.z0.glb.clouddn.com/pearl-boy.jpg" alt="Pearl Boy"></p>
<blockquote>
<p>This is a continuation from <a href="webgl-fundamentals.html">WebGL Fundamentals</a>.<br>If you haven’t read about how WebGL works you might want to <a href="webgl-how-it-works.html">read this first</a>.</p>
</blockquote>
<p>本章内容紧接<a href="http://webglfundamentals.org/webgl/lessons/webgl-fundamentals.html" target="_blank" rel="external">WebGL 基本原理</a>来进行介绍。如果你还不了解 WebGL 的工作机制，那么你可能需要先来读读这篇文章<a href="http://webglfundamentals.org/webgl/lessons/webgl-how-it-works.html" target="_blank" rel="external">WebGL 工作机制</a>。</p>
<blockquote>
<p>We’ve talked about shaders and GLSL but haven’t really given them any specific details.<br>I think I was hoping it would be clear by example but let’s try to make it clearer just in case.</p>
</blockquote>
<p>在前面的几篇文章中，我们已经提到了着色器和 GLSL 的相关知识，但是并没有对它们进行更多的解释和详细说明。我一直认为举例来介绍相关概念可以让你更容易接受，但是为了让你有更清晰的认识，我准备在这里对它们做更加详细的说明。</p>
<blockquote>
<p>As mentioned in <a href="webgl-how-it-works.html">how it works</a> WebGL requires 2 shaders every time you<br>draw something. A <em>vertex shader</em> and a <em>fragment shader</em>. Each shader is a <em>function</em>. A vertex<br>shader and fragment shader are linked together into a shader program (or just program). A typical<br>WebGL app will have many shader programs.</p>
</blockquote>
<p>正如在<a href="http://webglfundamentals.org/webgl/lessons/webgl-how-it-works.html" target="_blank" rel="external">WebGL 工作机制</a>中提到的那样，当我们需要绘制图形的时候，WebGL 需要使用2种着色器：<em>顶点着色器</em>和<em>片元着色器</em>。着色器就是一个<em>函数方法</em>。顶点着色器和片元着色器在着色器程序（或者程序）中被连接到一起。一个典型的 WebGL 应用包含多个着色器程序。</p>
<blockquote>
<p>译者注：这里的着色器程序应该是指 shader program 对象。program 对象有且仅有一个顶点着色器对象和一个片元着色器对象连接到它。链接 program 对象后，可以产生最终的可执行程序，它包含最后可以在硬件上执行的硬件指令。</p>
</blockquote>
<a id="more"></a>
<blockquote>
<h2 id="Vertex_Shader">Vertex Shader</h2></blockquote>
<h2 id="顶点着色器">顶点着色器</h2><blockquote>
<p>A Vertex Shader’s job is to generate clipspace coordinates. It always takes the form</p>
</blockquote>
<p>顶点着色器的工作是用来生成空间位置坐标。它一般像下面这样来使用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">   gl_Position = doMathToMakeClipspaceCoordinates</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Your shader is called once per vertex. Each time it’s called you are required to set the<br>the special global variable, <code>gl_Position</code> to some clipspace coordinates.</p>
</blockquote>
<p>每个顶点都会调用一次着色器。当它每次被调用的时候，你需要将一些空间坐标设置给一个特殊的全局变量 <code>gl_Position</code>。</p>
<blockquote>
<p>Vertex shaders need data. They can get that data in 3 ways.</p>
<ol>
<li><a href="#attributes">Attributes</a> (data pulled from buffers)</li>
<li><a href="#uniforms">Uniforms</a> (values that stay the same during for all vertices of a single draw call)</li>
<li><a href="#textures-in-vertex-shaders">Textures</a> (data from pixels/texels)</li>
</ol>
</blockquote>
<p>顶点着色器需要一些必须的数据，它们一般有3种获取方式。</p>
<ol>
<li><a href="#attributes">Attribute</a> (从缓冲区对象中拉取数据)</li>
<li><a href="#uniforms">Uniform</a> (在绘制过程中所有顶点都需要的、固定的数据值)</li>
<li><a href="#textures-in-vertex-shaders">Texture</a> (像素/纹理元素数据)</li>
</ol>
<blockquote>
<h3 id="Attributes">Attributes</h3></blockquote>
<h3 id="Attribute">Attribute</h3><blockquote>
<p>The most common way is through buffers and <em>attributes</em>.<br><a href="webgl-how-it-works.html">How it works</a> covered buffers and<br>attributes. You create buffers,</p>
</blockquote>
<p>给顶点着色器传递数据，最常用的方式是通过缓冲区对象和 <em>attribute</em>。<a href="http://webglfundamentals.org/webgl/lessons/webgl-how-it-works.html" target="_blank" rel="external">工作机制</a>中已经介绍了缓冲区对象和 attribute 相关内容。我们可以像下面这样来创建缓冲区对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buf = gl.createBuffer();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>put data in those buffers</p>
</blockquote>
<p>将数据放入缓冲区对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gl.bindBuffer(gl.ARRAY_BUFFER, buf);</span><br><span class="line">gl.bufferData(gl.ARRAY_BUFFER, someData, gl.STATIC_DRAW);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Then, given a shader program you made you look up the location of its attributes,</p>
</blockquote>
<p>然后，获取 attribute 变量的地址：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> positionLoc = gl.getAttribLocation(someShaderProgram, <span class="string">"a_position"</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>then tell WebGL how to pull data out of those buffers and into the attribute</p>
</blockquote>
<p>然后，告诉 WebGL 如何从缓冲区对象中获取数据，并把这些数据放入 attribute 变量中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从缓冲区对象中获取数据并传递给这个 attribute 变量</span></span><br><span class="line">gl.enableVertexAttribArray(positionLoc);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> numComponents = <span class="number">3</span>;  <span class="comment">// (x, y, z)</span></span><br><span class="line"><span class="keyword">var</span> type = gl.FLOAT;</span><br><span class="line"><span class="keyword">var</span> normalize = <span class="literal">false</span>;  <span class="comment">// 保持值不变</span></span><br><span class="line"><span class="keyword">var</span> offset = <span class="number">0</span>;         <span class="comment">// 从缓冲区起始位置开始</span></span><br><span class="line"><span class="keyword">var</span> stride = <span class="number">0</span>;         <span class="comment">// 到下一个顶点需要移动的字节数</span></span><br><span class="line">                        <span class="comment">// 0表示使用符合类型大小的 stride</span></span><br><span class="line"></span><br><span class="line">gl.vertexAttribPointer(positionLoc, numComponents, type, <span class="literal">false</span>, stride, offset);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>In <a href="webgl-fundamentals.html">WebGL fundamentals</a> we showed that we can do no math<br>in the shader and just pass the data directly through.</p>
</blockquote>
<p>我们已经在<a href="http://webglfundamentals.org/webgl/lessons/webgl-fundamentals.html" target="_blank" rel="external">WebGL 基本原理</a>中说明，在着色器中不做数学运算，只是直接传递数据值而已：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">attribute vec4 a_position;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">   gl_Position = a_position;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>If we put clipspace vertices into our buffers it will work.</p>
</blockquote>
<p>当我们将空间坐标数据放入缓冲区对象时，程序就正常运行了。</p>
<blockquote>
<p>Attributes can use <code>float</code>, <code>vec2</code>, <code>vec3</code>, <code>vec4</code>, <code>mat2</code>, <code>mat3</code>, and <code>mat4</code> as types.</p>
</blockquote>
<p>attribute 变量可以使用的数据类型有：<code>float</code>、<code>vec2</code>、<code>vec3</code>、<code>vec4</code>、<code>mat2</code>、<code>mat3</code> 和 <code>mat4</code>。</p>
<blockquote>
<h3 id="Uniforms">Uniforms</h3></blockquote>
<h3 id="Uniform">Uniform</h3><blockquote>
<p>For a vertex shader uniforms are values passed to the vertex shader that stay the same<br>for all vertices in a draw call. As a very simple example we could add an offset to<br>the vertex shader above</p>
</blockquote>
<p>对于顶点着色器而言，uniform 变量用来存储那些在绘制过程中所有顶点都共用的数据值。举个简单的例子，我们给上文的顶点着色器添加一个 offset 参数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">attribute vec4 a_position;</span><br><span class="line">uniform vec4 u_offset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">   gl_Position = a_position + u_offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>And now we could offset every vertex by a certain amount. First we’d look up the<br>location of the uniform</p>
</blockquote>
<p>现在我们可以给每个顶点都设置一个具体的偏移量了。首先，我们来获取下 uniform 变量的地址：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> offsetLoc = gl.getUniformLocation(someProgram, <span class="string">"u_offset"</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>And then before drawing we’d set the uniform</p>
</blockquote>
<p>然后，在绘制前我们需要先设置下 uniform 变量的值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gl.uniform4fv(offsetLoc, [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]);  <span class="comment">// 将它移动到视图的右半边</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Uniforms can be many types. For each type you have to call the corresponding function to set it.</p>
</blockquote>
<p>uniform 变量有多种类型。对于不同的类型，你只有调用正确的方法才可以设置变量值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">gl.uniform1f (floatUniformLoc, v);                 <span class="comment">// for float</span></span><br><span class="line">gl.uniform1fv(floatUniformLoc, [v]);               <span class="comment">// for float or float array</span></span><br><span class="line">gl.uniform2f (vec2UniformLoc,  v0, v1);            <span class="comment">// for vec2</span></span><br><span class="line">gl.uniform2fv(vec2UniformLoc,  [v0, v1]);          <span class="comment">// for vec2 or vec2 array</span></span><br><span class="line">gl.uniform3f (vec3UniformLoc,  v0, v1, v2);        <span class="comment">// for vec3</span></span><br><span class="line">gl.uniform3fv(vec3UniformLoc,  [v0, v1, v2]);      <span class="comment">// for vec3 or vec3 array</span></span><br><span class="line">gl.uniform4f (vec4UniformLoc,  v0, v1, v2, v4);    <span class="comment">// for vec4</span></span><br><span class="line">gl.uniform4fv(vec4UniformLoc,  [v0, v1, v2, v4]);  <span class="comment">// for vec4 or vec4 array</span></span><br><span class="line"></span><br><span class="line">gl.uniformMatrix2fv(mat2UniformLoc, <span class="literal">false</span>, [  <span class="number">4</span>x element array ])  <span class="comment">// for mat2 or mat2 array</span></span><br><span class="line">gl.uniformMatrix3fv(mat3UniformLoc, <span class="literal">false</span>, [  <span class="number">9</span>x element array ])  <span class="comment">// for mat3 or mat3 array</span></span><br><span class="line">gl.uniformMatrix4fv(mat4UniformLoc, <span class="literal">false</span>, [ <span class="number">16</span>x element array ])  <span class="comment">// for mat4 or mat4 array</span></span><br><span class="line"></span><br><span class="line">gl.uniform1i (intUniformLoc,   v);                 <span class="comment">// for int</span></span><br><span class="line">gl.uniform1iv(intUniformLoc, [v]);                 <span class="comment">// for int or int array</span></span><br><span class="line">gl.uniform2i (ivec2UniformLoc, v0, v1);            <span class="comment">// for ivec2</span></span><br><span class="line">gl.uniform2iv(ivec2UniformLoc, [v0, v1]);          <span class="comment">// for ivec2 or ivec2 array</span></span><br><span class="line">gl.uniform3i (ivec3UniformLoc, v0, v1, v2);        <span class="comment">// for ivec3</span></span><br><span class="line">gl.uniform3iv(ivec3UniformLoc, [v0, v1, v2]);      <span class="comment">// for ivec3 or ivec3 array</span></span><br><span class="line">gl.uniform4i (ivec4UniformLoc, v0, v1, v2, v4);    <span class="comment">// for ivec4</span></span><br><span class="line">gl.uniform4iv(ivec4UniformLoc, [v0, v1, v2, v4]);  <span class="comment">// for ivec4 or ivec4 array</span></span><br><span class="line"></span><br><span class="line">gl.uniform1i (sampler2DUniformLoc,   v);           <span class="comment">// for sampler2D (textures)</span></span><br><span class="line">gl.uniform1iv(sampler2DUniformLoc, [v]);           <span class="comment">// for sampler2D or sampler2D array</span></span><br><span class="line"></span><br><span class="line">gl.uniform1i (samplerCubeUniformLoc,   v);         <span class="comment">// for samplerCube (textures)</span></span><br><span class="line">gl.uniform1iv(samplerCubeUniformLoc, [v]);         <span class="comment">// for samplerCube or samplerCube array</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>There’s also types <code>bool</code>, <code>bvec2</code>, <code>bvec3</code>, and <code>bvec4</code>. They use either the <code>gl.uniform?f?</code> or <code>gl.uniform?i?</code><br>functions.</p>
</blockquote>
<p>其它的还有<code>bool</code>、<code>bvec2</code>、<code>bvec3</code> 和 <code>bvec4</code> 的数据类型。它们可以使用形如 <code>gl.uniform?f?</code> 或 <code>gl.uniform?i?</code> 的方法即可。</p>
<blockquote>
<p>Note that for an array you can set all the uniforms of the array at once. For example</p>
</blockquote>
<p>注意，你可以使用数组一次性给 uniform 数组形式的变量赋值。举例如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in shader</span></span><br><span class="line">uniform vec2 u_someVec2[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// in JavaScript at init time</span></span><br><span class="line"><span class="keyword">var</span> someVec2Loc = gl.getUniformLocation(someProgram, <span class="string">"u_someVec2"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// at render time</span></span><br><span class="line">gl.uniform2fv(someVec2Loc, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]);  <span class="comment">// set the entire array of u_someVec3</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>But if you want to set individual elements of the array you must look up the location of<br>each element individually.</p>
</blockquote>
<p>但是，如果你想要单独设置数组中的元素值，那你必须要单独查询每一个元素的地址。然后，再针对每一个元素分别赋值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in JavaScript at init time</span></span><br><span class="line"><span class="keyword">var</span> someVec2Element0Loc = gl.getUniformLocation(someProgram, <span class="string">"u_someVec2[0]"</span>);</span><br><span class="line"><span class="keyword">var</span> someVec2Element1Loc = gl.getUniformLocation(someProgram, <span class="string">"u_someVec2[1]"</span>);</span><br><span class="line"><span class="keyword">var</span> someVec2Element2Loc = gl.getUniformLocation(someProgram, <span class="string">"u_someVec2[2]"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// at render time</span></span><br><span class="line">gl.uniform2fv(someVec2Element0Loc, [<span class="number">1</span>, <span class="number">2</span>]);  <span class="comment">// set element 0</span></span><br><span class="line">gl.uniform2fv(someVec2Element1Loc, [<span class="number">3</span>, <span class="number">4</span>]);  <span class="comment">// set element 1</span></span><br><span class="line">gl.uniform2fv(someVec2Element2Loc, [<span class="number">5</span>, <span class="number">6</span>]);  <span class="comment">// set element 2</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Similarly if you create a struct</p>
</blockquote>
<p>类似的，如果你要创建一个结构体：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct SomeStruct &#123;</span><br><span class="line">  bool active;</span><br><span class="line">  vec2 someVec2;</span><br><span class="line">&#125;;</span><br><span class="line">uniform SomeStruct u_someThing;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>you have to look up each field individually</p>
</blockquote>
<p>你需要单独去获取每一个属性的地址：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someThingActiveLoc = gl.getUniformLocation(someProgram, <span class="string">"u_someThing.active"</span>);</span><br><span class="line"><span class="keyword">var</span> someThingSomeVec2Loc = gl.getUniformLocation(someProgram, <span class="string">"u_someThing.someVec2"</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<h3 id="Textures_in_Vertex_Shaders">Textures in Vertex Shaders</h3></blockquote>
<h3 id="顶点着色器中的纹理（texture）">顶点着色器中的纹理（texture）</h3><blockquote>
<p>See <a href="#textures-in-fragment-shaders">Textures in Fragment Shaders</a>.</p>
</blockquote>
<p>可参考<a href="http://webglfundamentals.org/webgl/lessons/webgl-shaders-and-glsl.html#textures-in-fragment-shaders" target="_blank" rel="external">片元着色器中的纹理</a>。</p>
<blockquote>
<h2 id="Fragment_Shader">Fragment Shader</h2></blockquote>
<h2 id="片元着色器">片元着色器</h2><blockquote>
<p>A Fragment Shader’s job is to provide a color for the current pixel being rasterized.<br>It always takes the form</p>
</blockquote>
<p>片元着色器的工作主要是为当前进行光栅化的像素提供颜色值。它一般如下面这样的形式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">precision mediump float;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">   gl_FragColor = doMathToMakeAColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Your fragment shader is called once per pixel. Each time it’s called you are required<br>to set the special global variable, <code>gl_FragColor</code> to some color.</p>
</blockquote>
<p>每个像素都会调用一次片元着色器。每当它被调用的时候，你都需要给一个特殊的全局变量 <code>gl_FragColor</code> 设置颜色值。</p>
<blockquote>
<p>Fragment shaders need data. They can get data in 3 ways</p>
</blockquote>
<p>片元着色器也需要数据，它们通常有3种获取方式：</p>
<blockquote>
<ol>
<li><a href="#uniforms">Uniforms</a> (values that stay the same for every pixel of a single draw call)</li>
<li><a href="#textures-in-fragment-shaders">Textures</a> (data from pixels/texels)</li>
<li><a href="#varyings">Varyings</a> (data passed from the vertex shader and interpolated)</li>
</ol>
</blockquote>
<ol>
<li><a href="#uniforms">Uniform</a> (在绘制过程中每个像素都需要的、固定的变量值)</li>
<li><a href="#textures-in-fragment-shaders">Texture</a> (像素/纹理元素数据)</li>
<li><a href="#varyings">Varying</a> (从顶点着色器传递过来并且经过内插过程的数据)</li>
</ol>
<blockquote>
<h3 id="Uniforms_in_Fragment_Shaders">Uniforms in Fragment Shaders</h3></blockquote>
<h3 id="片元着色器中的_uniform_变量">片元着色器中的 uniform 变量</h3><blockquote>
<p>See <a href="#uniforms">Uniforms in Vertex Shaders</a>.</p>
</blockquote>
<p>可参考上文顶点着色器中关于 uniform 变量的介绍。</p>
<blockquote>
<h3 id="Textures_in_Fragment_Shaders">Textures in Fragment Shaders</h3></blockquote>
<h3 id="片元着色器中的纹理">片元着色器中的纹理</h3><blockquote>
<p>Getting a value from a texture in a shader we create a <code>sampler2D</code> uniform and use the GLSL<br>function <code>texture2D</code> to extract a value from it.</p>
</blockquote>
<p>为了从纹理中获取数据，我们需要创建一个 uniform 类型的 <code>sampler2D</code> 变量，然后使用 GLSL 中的 <code>texture2D</code> 方法来导出数据。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">precision mediump float;</span><br><span class="line"></span><br><span class="line">uniform sampler2D u_texture;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">   vec2 texcoord = vec2(<span class="number">0.5</span>, <span class="number">0.5</span>)  <span class="comment">// get a value from the middle of the texture</span></span><br><span class="line">   gl_FragColor = texture2D(u_texture, texcoord);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>What data comes out of the texture is <a href="webgl-3d-textures.html">dependent on many settings</a>.<br>At a minimum we need to create and put data in the texture, for example</p>
</blockquote>
<p>纹理会导出什么样的数据呢？这<a href="http://webglfundamentals.org/webgl/lessons/webgl-3d-textures.html" target="_blank" rel="external">依赖于很多配置项</a>。<br>我们至少要创建纹理并把数据传递过来，如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tex = gl.createTexture();</span><br><span class="line">gl.bindTexture(gl.TEXTURE_2D, tex);</span><br><span class="line"><span class="keyword">var</span> level = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> width = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> height = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> data = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>, <span class="number">255</span>]);</span><br><span class="line">gl.texImage2D(gl.TEXTURE_2D, level, gl.RGBA, width, height, <span class="number">0</span>, gl.RGBA, gl.UNSIGNED_BYTE, data);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Then look up the uniform location in the shader program</p>
</blockquote>
<p>然后，获取 uniform 变量的地址：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someSamplerLoc = gl.getUniformLocation(someProgram, <span class="string">"u_texture"</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>WebGL then requires you to bind it to a texture unit</p>
</blockquote>
<p>然后，我们需要将它绑定到一个纹理单元：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> unit = <span class="number">5</span>;  <span class="comment">// Pick some texture unit</span></span><br><span class="line">gl.activeTexture(gl.TEXTURE0 + unit);</span><br><span class="line">gl.bindTexture(gl.TEXTURE_2D, tex);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>And tell the shader which unit you bound the texture to</p>
</blockquote>
<p>并且要告诉着色器你刚才绑定的纹理单元：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gl.uniform1i(someSamplerLoc, unit);</span><br></pre></td></tr></table></figure>
<blockquote>
<h3 id="Varyings">Varyings</h3></blockquote>
<h3 id="varying">varying</h3><blockquote>
<p>A varying is a way to pass a value from a vertex shader to a fragment shader which we<br>covered in <a href="webgl-how-it-works.html">how it works</a>.</p>
</blockquote>
<p>我们已经在<a href="http://webglfundamentals.org/webgl/lessons/webgl-how-it-works.html" target="_blank" rel="external">WebGL 工作机制</a>中介绍过了，varying 变量主要用来从顶点着色器向片元着色器传递数值。</p>
<blockquote>
<p>To use a varying we need to declare matching varyings in both a vertex and fragment shader.<br>We set the varying in the vertex shader with some value per vertex. When WebGL draws pixels<br>it will interpolate between those values and pass them to the corresponding varying in<br>the fragment shader</p>
</blockquote>
<p>为了使用它，我们需要在顶点着色器和片元着色器中声明同名的 varying 变量。在顶点着色器中，我们根据每个顶点来设置 varying 变量值。当 WebGL 绘制像素的时候，它会对这些 varying 变量值执行内插过程，然后把处理后得到的相关值传递给片元着色器中的同名 varying 变量。</p>
<blockquote>
<p>Vertex shader</p>
</blockquote>
<p>顶点着色器</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">attribute vec4 a_position;</span><br><span class="line"></span><br><span class="line">uniform vec4 u_offset;</span><br><span class="line"></span><br><span class="line">varying vec4 v_positionWithOffset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  gl_Position = a_position + u_offset;</span><br><span class="line">  v_positionWithOffset = a_position + u_offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Fragment shader</p>
</blockquote>
<p>片元着色器</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">precision mediump float;</span><br><span class="line"></span><br><span class="line">varying vec4 v_positionWithOffset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="comment">// convert from clipsapce (-1 &lt;-&gt; +1) to color space (0 -&gt; 1).</span></span><br><span class="line">  vec4 color = v_positionWithOffset * <span class="number">0.5</span> + <span class="number">0.5</span></span><br><span class="line">  gl_FragColor = color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>The example above is a mostly nonsense example. It doesn’t generally make sense to<br>directly copy the clipspace values to the fragment shader and use them as colors. Nevertheless<br>it will work and produce colors.</p>
</blockquote>
<p>上面的例子并不太明智。直接将空间坐标值传递给片元着色器并用作颜色值看起来是非常不合理的做法。然而，这确实能让程序运行起来，并渲染出了颜色。</p>
<h2 id="GLSL">GLSL</h2><blockquote>
<p>GLSL stands for Graphics Library Shader Language. It’s the language shaders are written<br>in. It has some special semi unique features that are certainly not common in JavaScript.<br>It’s designed to do the math that is commonly needed to compute things for rasterizing<br>graphics. So for example it has built in types like <code>vec2</code>, <code>vec3</code>, and <code>vec4</code> which<br>represent 2 values, 3 values, and 4 values respectively. Similarly it has <code>mat2</code>, <code>mat3</code><br>and <code>mat4</code> which represent 2x2, 3x3, and 4x4 matrices. You can do things like multiply<br>a <code>vec</code> by a scalar.</p>
</blockquote>
<p>GLSL 的全称为 Graphics Library Shader Language。它是编写着色器的编程语言。在 GLSL 中，有很多特性与 JavaScript 有很大区别。GLSL 在设计的时候，主要是想用它来解决图形光栅化过程中的数学运算的。因此，你在例子中可以看到分别携带了2个、3个甚至4个值的<code>vec2</code>、<code>vec3</code>和<code>vec4</code>的数据类型。同样，它还有<code>mat2</code>、<code>mat3</code>和<code>mat4</code>的类型，分别表示2x2、3x3和4x4的矩阵。你甚至可以方便的对一个<code>vec</code>和一个标量做乘法计算。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vec4 a = vec4(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">vec4 b = a * <span class="number">2.0</span>;</span><br><span class="line"><span class="comment">// b is now vec4(2, 4, 6, 8);</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Similarly it can do matrix multiplication and vector to matrix multiplication</p>
</blockquote>
<p>同样的，它也可以做矩阵和矩阵、矢量和矩阵的乘法运算</p>
<blockquote>
<p>译者注：原文例子中，a、b、v 的值均已丢失，没办法知道具体值了，大家只要理解是矩阵和向量即可。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mat4 a = ???</span><br><span class="line">mat4 b = ???</span><br><span class="line">mat4 c = a * b;</span><br><span class="line"></span><br><span class="line">vec4 v = ???</span><br><span class="line">vec4 y = c * v;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>It also has various selectors for the parts of a vec. For a vec4</p>
</blockquote>
<p>它也包含了很多选择器，让你可以方便的选取矢量部分维度上的值。例如定义一个 vec4</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vec4 v;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><code>v.x</code> is the same as <code>v.s</code> and <code>v.r</code> and <code>v[0]</code>.</li>
<li><code>v.y</code> is the same as <code>v.t</code> and <code>v.g</code> and <code>v[1]</code>.</li>
<li><code>v.z</code> is the same as <code>v.p</code> and <code>v.b</code> and <code>v[2]</code>.</li>
<li><code>v.w</code> is the same as <code>v.q</code> and <code>v.a</code> and <code>v[3]</code>.</li>
</ul>
</blockquote>
<ul>
<li><code>v.x</code> 得到的值同 <code>v.s</code>、<code>v.r</code>和<code>v[0]</code>得到的值是完全一样的。</li>
<li><code>v.y</code> 得到的值同 <code>v.t</code>、<code>v.g</code>和<code>v[1]</code>得到的值是完全一样的。</li>
<li><code>v.z</code> 得到的值同 <code>v.p</code>、<code>v.b</code>和<code>v[2]</code>得到的值是完全一样的。</li>
<li><code>v.w</code> 得到的值同 <code>v.q</code>、<code>v.a</code>和<code>v[3]</code>得到的值是完全一样的。</li>
</ul>
<blockquote>
<p>译者注：因为矢量可以用来存储顶点的坐标、颜色和纹理坐标，所以 GLSL ES 支持以上三种分量名称，从而增加程序可读性。</p>
<p>It it able to <em>swizzle</em> vec components which means you can swap or repeat components.</p>
</blockquote>
<p>你还可以通过对矢量同时抽取多个分量，从而实现 <em>混合</em> 的过程。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.yyyy</span><br></pre></td></tr></table></figure>
<blockquote>
<p>is the same as</p>
</blockquote>
<p>它等价于下面这种形式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vec4(v.y, v.y, v.y, v.y)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Similarly</p>
</blockquote>
<p>同样可以使用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.bgra</span><br></pre></td></tr></table></figure>
<blockquote>
<p>is the same as</p>
</blockquote>
<p>或者这种</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vec4(v.b, v.g, v.r, v.a)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>when constructing a vec or a mat you can supply multiple parts at once. So for example</p>
</blockquote>
<p>当构造矢量或者矩阵的时候，你也可以一次性提供多个部分来完成构造。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vec4(v.rgb, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Is the same as</p>
</blockquote>
<p>等价于</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vec4(v.r, v.g, v.b, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>One thing you’ll likely get caught up on is that GLSL is very type strict.</p>
</blockquote>
<p>编程中时刻要注意 GLSL 是一种强类型语言，不然极易导致程序报错。如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float f = <span class="number">1</span>;  <span class="comment">// ERROR 1 is an int. You can't assign an int to a float</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>The correct way is one of these</p>
</blockquote>
<p>正确的方法是像下面这么写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float f = <span class="number">1.0</span>;      <span class="comment">// 使用 float</span></span><br><span class="line">float f = float(<span class="number">1</span>)  <span class="comment">// 把 integer 转换为 float</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>The example above of <code>vec4(v.rgb, 1)</code> doesn’t complain about the <code>1</code> because <code>vec4</code> is<br>casting the things inside just like <code>float(1)</code>.</p>
</blockquote>
<p>在上面 <code>vec4(v.rgb, 1)</code> 的例子中也使用了 <code>1</code>，但是它并没有报错。这是为什么呢？因为 <code>vec4</code> 在内部已经对这些参数做了类似 <code>float(1)</code> 的转换操作。</p>
<blockquote>
<p>GLSL has a bunch of built in functions. Many of them operate on multiple components at once.<br>So for example</p>
</blockquote>
<p>GLSL 包含了很多内置功能函数。其中很多函数操作都是一次操作多个分量。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T sin(T angle)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Means T can be <code>float</code>, <code>vec2</code>, <code>vec3</code> or <code>vec4</code>. If you pass in <code>vec4</code> you get <code>vec4</code> back<br>which the sine of each of the components. In other words if <code>v</code> is a <code>vec4</code> then</p>
</blockquote>
<p>T 可以使用 <code>float</code>、<code>vec2</code>、<code>vec3</code> 或者 <code>vec4</code> 的类型。如果你传给函数的参数为 <code>vec4</code> 类型，那么你得到的操作结果就是一个在每个分量上执行了 sin 操作的 <code>vec4</code>。换句话说，假设 <code>v</code> 是 <code>vec4</code> 类型，那么</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vec4 s = sin(v);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>is the same as</p>
</blockquote>
<p>得到的结果同下面的操作是一样的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vec4 s = vec4(sin(v.x), sin(v.y), sin(v.z), sin(v.w));</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Sometimes one argument is a float and the rest is <code>T</code>. That means that float will be applied<br>to all the components. For example if <code>v1</code> and <code>v2</code> are <code>vec4</code> and <code>f</code> is a float then</p>
</blockquote>
<p>有些时候，可能一个参数是 float 类型，其他部分的参数为 <code>T</code> 类型。那么时候，float 类型的参数会参与各个分量的计算。例如，假设 <code>v1</code> 和 <code>v2</code> 都是 <code>vec4</code> 类型，而 <code>f</code> 是 float 类型，然后执行下面的操作：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vec4 m = mix(v1, v2, f);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>is the same as</p>
</blockquote>
<p>操作结果同下面的形式是等价的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vec4 m = vec4(</span><br><span class="line">  mix(v1.x, v2.x, f),</span><br><span class="line">  mix(v1.y, v2.y, f),</span><br><span class="line">  mix(v1.z, v2.z, f),</span><br><span class="line">  mix(v1.w, v2.w, f));</span><br></pre></td></tr></table></figure>
<blockquote>
<p>You can see a list of all the GLSL functions on the last page of <a href="https://www.khronos.org/files/webgl/webgl-reference-card-1_0.pdf" target="_blank" rel="external">the WebGL<br>Reference Card</a>.<br>If you like really dry and verbose stuff you can try<br><a href="https://www.khronos.org/files/opengles_shading_language.pdf" target="_blank" rel="external">the GLSL spec</a>.</p>
</blockquote>
<p>你可以在<a href="https://www.khronos.org/files/webgl/webgl-reference-card-1_0.pdf" target="_blank" rel="external">the WebGL<br>Reference Card</a>中查看 GLSL 的全部函数列表。如果喜欢更详细的介绍，那你可以参考<a href="https://www.khronos.org/files/opengles_shading_language.pdf" target="_blank" rel="external">the GLSL spec</a>。</p>
<blockquote>
<h2 id="Putting_it_all_togehter">Putting it all togehter</h2></blockquote>
<h2 id="总结一下">总结一下</h2><blockquote>
<p>That’s the point of this entire series of posts. WebGL is all about creating various shaders, supplying<br>the data to those shaders and then calling <code>gl.drawArrays</code> or <code>gl.drawElements</code> to have WebGL process<br>the vertices by calling the current vertex shader for each vertex and then render pixels by calling the<br>the current fragment shader for each pixel.</p>
</blockquote>
<p>这里介绍的内容是整个系列文章中的重点内容。其实，WebGL 可以总结如下：创建各种着色器，给着色器提供数据，然后调用 <code>gl.drawArrays</code> 或者 <code>gl.drawElements</code> 方法来让 WebGL 处理器根据顶点着色器对每个顶点进行处理，最后使用片元着色器对每个像素进行渲染。</p>
<blockquote>
<p>Actually creating the shaders requires several lines of code. Since those lines are the same in<br>most WebGL programs and since once written you can pretty much ignore them <a href="webgl-boilerplate.html">how to compile GLSL shaders<br>and link them into a shader program is covered here</a>.</p>
</blockquote>
<p>实际上，创建着色器需要大量代码。然而，在大多数 WebGL 程序中这些代码都是相同的。因此，这些代码介绍一次就可以了，后续学习你可以完全忽略它们了。更多内容可以参考<a href="http://webglfundamentals.org/webgl/lessons/webgl-boilerplate.html" target="_blank" rel="external">how to compile GLSL shaders<br>and link them into a shader program is covered here</a>。</p>
<blockquote>
<p>If you’re just starting from here you can go in 2 directions. If you are interested in image procesing<br>I’ll show you <a href="webgl-image-processing.html">how to do some 2D image processing</a>.<br>If you are interesting in learning about translation,<br>rotation and scale then <a href="webgl-2d-translation.html">start here</a>.</p>
</blockquote>
<p>从这里开始，你有两个方向可以去深入学习。如果对图像处理感兴趣，你可以去学习<a href="http://webglfundamentals.org/webgl/lessons/webgl-image-processing.html" target="_blank" rel="external">how to do some 2D image processing</a>。如果对变换、旋转和缩放感兴趣，那么你可以去<a href="http://webglfundamentals.org/webgl/lessons/webgl-2d-translation.html" target="_blank" rel="external">这里</a>学习。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文地址：<a href="http://webglfundamentals.org/webgl/lessons/webgl-shaders-and-glsl.html">http://webglfundamentals.org/webgl/lessons/webgl-shaders-and-glsl.html</a></p>
<p><img src="http://7tt058.com1.z0.glb.clouddn.com/pearl-boy.jpg" alt="Pearl Boy"></p>
<blockquote>
<p>This is a continuation from <a href="webgl-fundamentals.html">WebGL Fundamentals</a>.<br>If you haven’t read about how WebGL works you might want to <a href="webgl-how-it-works.html">read this first</a>.</p>
</blockquote>
<p>本章内容紧接<a href="http://webglfundamentals.org/webgl/lessons/webgl-fundamentals.html">WebGL 基本原理</a>来进行介绍。如果你还不了解 WebGL 的工作机制，那么你可能需要先来读读这篇文章<a href="http://webglfundamentals.org/webgl/lessons/webgl-how-it-works.html">WebGL 工作机制</a>。</p>
<blockquote>
<p>We’ve talked about shaders and GLSL but haven’t really given them any specific details.<br>I think I was hoping it would be clear by example but let’s try to make it clearer just in case.</p>
</blockquote>
<p>在前面的几篇文章中，我们已经提到了着色器和 GLSL 的相关知识，但是并没有对它们进行更多的解释和详细说明。我一直认为举例来介绍相关概念可以让你更容易接受，但是为了让你有更清晰的认识，我准备在这里对它们做更加详细的说明。</p>
<blockquote>
<p>As mentioned in <a href="webgl-how-it-works.html">how it works</a> WebGL requires 2 shaders every time you<br>draw something. A <em>vertex shader</em> and a <em>fragment shader</em>. Each shader is a <em>function</em>. A vertex<br>shader and fragment shader are linked together into a shader program (or just program). A typical<br>WebGL app will have many shader programs.</p>
</blockquote>
<p>正如在<a href="http://webglfundamentals.org/webgl/lessons/webgl-how-it-works.html">WebGL 工作机制</a>中提到的那样，当我们需要绘制图形的时候，WebGL 需要使用2种着色器：<em>顶点着色器</em>和<em>片元着色器</em>。着色器就是一个<em>函数方法</em>。顶点着色器和片元着色器在着色器程序（或者程序）中被连接到一起。一个典型的 WebGL 应用包含多个着色器程序。</p>
<blockquote>
<p>译者注：这里的着色器程序应该是指 shader program 对象。program 对象有且仅有一个顶点着色器对象和一个片元着色器对象连接到它。链接 program 对象后，可以产生最终的可执行程序，它包含最后可以在硬件上执行的硬件指令。</p>
</blockquote>]]>
    
    </summary>
    
      <category term="webgl" scheme="http://reygreen1.github.io/tags/webgl/"/>
    
      <category term="webgl" scheme="http://reygreen1.github.io/categories/webgl/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]WebGL 基础系列：WebGL 工作机制]]></title>
    <link href="http://reygreen1.github.io/2015/10/25/webgl-how-it-works/"/>
    <id>http://reygreen1.github.io/2015/10/25/webgl-how-it-works/</id>
    <published>2015-10-24T16:00:00.000Z</published>
    <updated>2015-11-03T05:55:42.000Z</updated>
    <content type="html"><![CDATA[<p>原文地址：<a href="http://webglfundamentals.org/webgl/lessons/webgl-how-it-works.html" target="_blank" rel="external">http://webglfundamentals.org/webgl/lessons/webgl-how-it-works.html</a></p>
<p><img src="http://7tt058.com1.z0.glb.clouddn.com/webgl-fixed-unctionality.gif" alt="webgl 流水线"></p>
<blockquote>
<p>This is a continuation from <a href="webgl-fundamentals.html">WebGL Fundamentals</a>.<br>Before we continue I think we need to discuss at a<br>basic level what WebGL and your GPU actually do.  There are basically 2<br>parts to this GPU thing.  The first part processes vertices (or streams of<br>data) into clipspace vertices.  The second part draws pixels based on the<br>first part.</p>
</blockquote>
<p>本文是上一章节<a href="http://webglfundamentals.org/webgl/lessons/webgl-fundamentals.html" target="_blank" rel="external">WebGL 基本原理</a>内容的延续。开始之前，我认为我们应该先理解 WebGL 和 GPU 在底层上的工作机制。GPU 其实主要处理两方面的事情，首先把顶点信息（或数据流）处理成 WebGL 空间中的顶点，然后再次基础上，逐像素绘制图形。</p>
<a id="more"></a>
<blockquote>
<p>When you call</p>
</blockquote>
<p>当我们调用下面的命令时</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gl.drawArrays(gl.TRIANGLE, 0, 9);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>The 9 there means “process 9 vertices” so here are 9 vertices being processed.</p>
</blockquote>
<p>参数中的9表示我们接下来需要处理9个顶点信息</p>
<p><img src="http://webglfundamentals.org/webgl/lessons/resources/vertex-shader-anim.gif" alt="处理过程"></p>
<blockquote>
<p>On the left is the data you provide.  The vertex shader is a function you<br>write in <a href="webgl-shaders-and-glsl.html">GLSL</a>.  It gets called once for each vertex.<br>You do some math and set the special variable <code>gl_Position</code> with a clipspace value<br>for the current vertex. The GPU takes that value and stores it internally.</p>
</blockquote>
<p>左边是我们提供的顶点数据，中间是我们着色器代码，它是用<a href="http://webglfundamentals.org/webgl/lessons/webgl-shaders-and-glsl.html" target="_blank" rel="external">GLSL</a>编写的函数。每个顶点都会调用一次顶点着色器，这里需要对当前的顶点做些运算，从而转换成 WebGL 空间数据提供给 <code>gl_Position</code> 变量。GPU 会使用这些数据并在内部存储起来。</p>
<blockquote>
<p>Assuming you’re drawing <code>TRIANGLES</code>, every time this first part generates 3<br>vertices the GPU uses them to make a triangle.  It figures out which<br>pixels the 3 points of the triangle correspond to, and then rasterizes the<br>triangle which is a fancy word for “draws it with pixels”.  For each<br>pixel it will call your fragment shader asking you what color to make that<br>pixel. Your fragment shader has to set a special variable <code>gl_FragColor</code><br>with the color it wants for that pixel.</p>
</blockquote>
<p>假设现在需要绘制 <code>三角形</code>，那么 GPU 会在第一个步骤中通过3个顶点来确定三角形的位置。然后，GPU 可以知道哪些像素是属于该三角形的，最后逐像素绘制三角形，我们称之为光栅化。针对每一个像素点，它都需要调用片元着色器来获取当前需要绘制的颜色值。片元着色器需要把像素上的颜色值设置到 <code>gl_FragColor</code> 变量中。</p>
<blockquote>
<p>That’s all very interesting but as you can see in our examples to up<br>this point the fragment shader has very little info per pixel.<br>Fortunately we can pass it more info.  We define “varyings” for each<br>value we want to pass from the vertex shader to the fragment shader.</p>
</blockquote>
<p>这就是全部有趣的地方，但是从例子中可以看到，我们当前在片元着色器上放置的像素信息还非常少。在后续的内容中，我们会给它提供更多的信息。如果需要从顶点着色器向片元着色器传递数据，那么我们需要为传递的每一个值设定 varying 变量。</p>
<blockquote>
<p>As a simple example, let’s just pass the clipspace coordinates we computed<br>directly from the vertex shader to the fragment shader.</p>
</blockquote>
<p>在当前这个简单的示例中，我们只需要从顶点着色器向片元着色器传递计算好的空间坐标数据。</p>
<blockquote>
<p>We’ll draw with a simple triangle.  Continuing from our<br><a href="webgl-2d-matrices.html">previous example</a> let’s change our F to a<br>triangle.</p>
</blockquote>
<p>我们先来绘制一个简单的三角形。示例代码来自于<a href="http://webglfundamentals.org/webgl/lessons/webgl-2d-matrices.html" target="_blank" rel="external">前一个例子</a>。我们稍微做下调整，将 F 修改为三角形。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将三角形相关数据传递给缓冲对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setGeometry</span><span class="params">(gl)</span> </span>&#123;</span><br><span class="line">  gl.bufferData(</span><br><span class="line">      gl.ARRAY_BUFFER,</span><br><span class="line">      <span class="keyword">new</span> <span class="built_in">Float32Array</span>([</span><br><span class="line">             <span class="number">0</span>, -<span class="number">100</span>,</span><br><span class="line">           <span class="number">150</span>,  <span class="number">125</span>,</span><br><span class="line">          -<span class="number">175</span>,  <span class="number">100</span>]),</span><br><span class="line">      gl.STATIC_DRAW);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>And we have to only draw 3 vertices.</p>
</blockquote>
<p>然后，我们只需要绘制3个顶点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绘制场景</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawScene</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 绘制几何图形</span></span><br><span class="line">  gl.drawArrays(gl.TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Then in our vertex shader we declare a <em>varying</em> to pass data to the<br>fragment shader.</p>
</blockquote>
<p>在顶点着色器中，我们需要声明一个 <em>varying</em> 变量来将数据传递给片元着色器。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">varying vec4 v_color;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="comment">// 通过矩阵生成多个位置数据</span></span><br><span class="line">  gl_Position = vec4((u_matrix * vec3(a_position, <span class="number">1</span>)).xy, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 坐标信息转换成颜色值</span></span><br><span class="line">  <span class="comment">// 坐标范围 [-1.0, 1.0]</span></span><br><span class="line">  <span class="comment">// 颜色值范围 [0.0, 1.0]</span></span><br><span class="line">   v_color = gl_Position * <span class="number">0.5</span> + <span class="number">0.5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>And then we declare the same <em>varying</em> in the fragment shader.</p>
</blockquote>
<p>然后，我们在片元着色器中声明一个同名的 <em>varying</em> 变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">precision mediump float;</span><br><span class="line"></span><br><span class="line">varying vec4 v_color;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">   gl_FragColor = v_color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>WebGL will connect the varying in the vertex shader to the varying of the<br>same name and type in the fragment shader.</p>
</blockquote>
<p>WebGL 会将顶点着色器和片元着色器中的同名 varying 变量连接起来，这样他们的信息就“同步”了。</p>
<blockquote>
<p>译者注：这里的“同步”并不是直接传值，这其中发生了光栅化的过程，根据绘制的图形，对顶点着色器中的 varying 变量进行内插，然后再传递给片元着色器中的 varying 变量。</p>
</blockquote>
<hr>
<blockquote>
<p>Here’s the working version.</p>
</blockquote>
<p>下面是一个可执行的代码版本。</p>
<iframe class="webgl_example" style="width: 400px; height: 300px;" src="http://webglfundamentals.org/webgl/webgl-2d-triangle-with-position-for-color.html"></iframe>

<blockquote>
<p>Move, scale and rotate the rectangle.  Notice that since the colors are<br>computed from clipspace they don’t move with the rectangle.  They are<br>relative to the background.</p>
</blockquote>
<p>自己试试移动、缩放和旋转下那个三角形。你可能会注意到，三角形的颜色并不会跟随三角形一起移动。这是因为，颜色值是根据像素的坐标位置计算而来，它们只跟背景位置相关联。</p>
<blockquote>
<p>Now think about it.  We only compute 3 vertices.  Our vertex shader only<br>gets called 3 times therefore it’s only computing 3 colors yet our<br>triangle is many colors.  This is why it’s called a <em>varying</em>.</p>
</blockquote>
<p>现在我们在这里思考下。我们只计算了3个顶点，顶点着色器也只被调用了3次，因此只能计算3个颜色值，但是三角形内部有非常多的颜色，它们是如何计算出来的呢？这就是我们使用 <em>varying</em> 变量的原因。</p>
<blockquote>
<p>WebGL takes the 3 values we computed for each vertex and as it rasterizes<br>the triangle it interpolates between the values we computed for the<br>vertices.  For each pixel it calls our fragment shader with the<br>interpolated value for that pixel.</p>
</blockquote>
<p>WebGL 首先会使用我们计算好的3个顶点数据，然后在对三角形进行光栅化的时候，它会使用内插的方法来计算内部各个像素上的值。</p>
<blockquote>
<p>In the example above we start out with the 3 vertices</p>
</blockquote>
<p>在上面的例子中，我们开始有3个顶点值。</p>
<p>| Vertices |<br>| 0 | -100 |<br>| 150 | 125 |<br>| -175 | 100 |</p>
<blockquote>
<p>Our vertex shader applies a matrix to translate, rotate, scale and convert<br>to clipspace.  The defaults for translation, rotation and scale are<br>translation = 200, 150, rotation = 0, scale = 1,1 so that’s really only<br>translation.  Given our backbuffer is 400x300 our vertex shader applies<br>the matrix and then computes the following 3 clipspace vertices.</p>
</blockquote>
<p>顶点着色器使用矩阵来实现变换、旋转、缩放和坐标转换等操作。这里变换、旋转和缩放的默认值分别为 translation = 200, 150、rotation = 0、scale = 1,1 所以这里只看到了转换的效果。把绘图背景大小设置为 400x300，顶点着色器会使用矩阵来计算得出下面的3个空间坐标。</p>
<p>| values written to gl_Position |<br>| 0.000 | 0.660 |<br>| 0.750 | -0.830 |<br>| -0.875 | -0.660 |</p>
<blockquote>
<p>It also converts those to colorspace and writes them to the <em>varying</em> v_color that we declared.</p>
</blockquote>
<p>同时，也会将这些值转换成相应的颜色值，并将它们写入我们已经声明的<em>varying</em> v_color 变量。</p>
<p>| values written to v_color |<br>| 0.5000 | 0.750 | 0.5 |<br>| 0.8750 | 0.915 | 0.5 |<br>| 0.0625 | 0.170 | 0.5 |</p>
<blockquote>
<p>Those 3 values written to v_color are then interpolated and passed to the<br>fragment shader for each pixel.</p>
</blockquote>
<p>这3个被写入 v_color 的值会在经过内插的过程后传递给片元着色器，片元着色器因此可以恰当的得到图形上其他像素的颜色值。</p>
<iframe class="webgl_example" style="width: 400px; height: 300px;" src="http://webglfundamentals.org/webgl/lessons/resources/fragment-shader-anim.html"></iframe>

<blockquote>
<p>We can also pass in more data to the vertex shader which we can then pass<br>on to the fragment shader.  So for example let’s draw a rectangle, that<br>consists of 2 triangles, in 2 colors.  To do this we’ll add another<br>attribute to the vertex shader so we can pass it more data and we’ll pass<br>that data directly to the fragment shader.</p>
</blockquote>
<p>我们可以给顶点着色器传递更多的数据，以便于片元着色器可以使用这些数据。所以下面的例子，我们就来绘制一个矩形，它包含了两个不同颜色的三角形。为了达到这个目的，我们需要给顶点着色器添加一个 attribute 变量，这样片元着色器可以使用这些数据进行后续处理。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">attribute vec2 a_position;</span><br><span class="line">attribute vec4 a_color;</span><br><span class="line">...</span><br><span class="line">varying vec4 v_color;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">   ...</span><br><span class="line">  <span class="comment">// 复制属性值到 varying 变量</span></span><br><span class="line">   v_color = a_color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>We now have to supply colors for WebGL to use.</p>
</blockquote>
<p>现在可以提供颜色值给 WebGL 使用了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 获取存储位置</span></span><br><span class="line">  <span class="keyword">var</span> positionLocation = gl.getAttribLocation(program, <span class="string">"a_position"</span>);</span><br><span class="line">  <span class="keyword">var</span> colorLocation = gl.getAttribLocation(program, <span class="string">"a_color"</span>);</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 创建缓冲区对象</span></span><br><span class="line">  <span class="keyword">var</span> buffer = gl.createBuffer();</span><br><span class="line">  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);</span><br><span class="line">  gl.enableVertexAttribArray(colorLocation);</span><br><span class="line">  gl.vertexAttribPointer(colorLocation, <span class="number">4</span>, gl.FLOAT, <span class="literal">false</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置颜色</span></span><br><span class="line">  setColors(gl);</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置两个三角形的颜色</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setColors</span><span class="params">(gl)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Pick 2 random colors.</span></span><br><span class="line">  <span class="keyword">var</span> r1 = <span class="built_in">Math</span>.random();</span><br><span class="line">  <span class="keyword">var</span> b1 = <span class="built_in">Math</span>.random();</span><br><span class="line">  <span class="keyword">var</span> g1 = <span class="built_in">Math</span>.random();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> r2 = <span class="built_in">Math</span>.random();</span><br><span class="line">  <span class="keyword">var</span> b2 = <span class="built_in">Math</span>.random();</span><br><span class="line">  <span class="keyword">var</span> g2 = <span class="built_in">Math</span>.random();</span><br><span class="line"></span><br><span class="line">  gl.bufferData(</span><br><span class="line">      gl.ARRAY_BUFFER,</span><br><span class="line">      <span class="keyword">new</span> <span class="built_in">Float32Array</span>(</span><br><span class="line">        [ r1, b1, g1, <span class="number">1</span>,</span><br><span class="line">          r1, b1, g1, <span class="number">1</span>,</span><br><span class="line">          r1, b1, g1, <span class="number">1</span>,</span><br><span class="line">          r2, b2, g2, <span class="number">1</span>,</span><br><span class="line">          r2, b2, g2, <span class="number">1</span>,</span><br><span class="line">          r2, b2, g2, <span class="number">1</span>]),</span><br><span class="line">      gl.STATIC_DRAW);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>And here’s the result.</p>
</blockquote>
<p>下面就是最终的效果。</p>
<iframe class="webgl_example" style="width: 400px; height: 300px;" src="http://webglfundamentals.org/webgl/webgl-2d-rectangle-with-2-colors.html"></iframe>

<blockquote>
<p>Notice that we have 2 solid color triangles.  Yet we’re passing the values<br>in a <em>varying</em> so they are being varied or interpolated across the<br>triangle.  It’s just that we used the same color on each of the 3 vertices<br>of each triangle.  If we make each color different we’ll see the<br>interpolation.</p>
</blockquote>
<p>注意，现在我们有了2个纯色三角形。我们使用 <em>varying</em> 变量来设置相关值，这样它们可以方便的在三角形内部做内插。上面的例子中，三角形的3个顶点使用了相同的颜色，所以显示的是纯色的三角形。如果我们设置不同的颜色值，那么可以通过下面的代码来观察不同的效果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置2个三角形的颜色</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setColors</span><span class="params">(gl)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 每个顶点设置不同颜色</span></span><br><span class="line">  gl.bufferData(</span><br><span class="line">      gl.ARRAY_BUFFER,</span><br><span class="line">      <span class="keyword">new</span> <span class="built_in">Float32Array</span>(</span><br><span class="line">         [ <span class="built_in">Math</span>.random(), <span class="built_in">Math</span>.random(), <span class="built_in">Math</span>.random(), <span class="number">1</span>,</span><br><span class="line">           <span class="built_in">Math</span>.random(), <span class="built_in">Math</span>.random(), <span class="built_in">Math</span>.random(), <span class="number">1</span>,</span><br><span class="line">           <span class="built_in">Math</span>.random(), <span class="built_in">Math</span>.random(), <span class="built_in">Math</span>.random(), <span class="number">1</span>,</span><br><span class="line">           <span class="built_in">Math</span>.random(), <span class="built_in">Math</span>.random(), <span class="built_in">Math</span>.random(), <span class="number">1</span>,</span><br><span class="line">           <span class="built_in">Math</span>.random(), <span class="built_in">Math</span>.random(), <span class="built_in">Math</span>.random(), <span class="number">1</span>,</span><br><span class="line">           <span class="built_in">Math</span>.random(), <span class="built_in">Math</span>.random(), <span class="built_in">Math</span>.random(), <span class="number">1</span>]),</span><br><span class="line">      gl.STATIC_DRAW);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>And now we see the interpolated <em>varying</em>.</p>
</blockquote>
<p>现在我们可以看到变化后的 <em>varying</em> 效果了。</p>
<iframe class="webgl_example" style="width: 400px; height: 300px;" src="http://webglfundamentals.org/webgl/webgl-2d-rectangle-with-random-colors.html"></iframe>

<blockquote>
<p>Not very exciting I suppose but it does demonstrate using more than one<br>attribute and passing data from a vertex shader to a fragment shader.  If<br>you check out <a href="http://webglfundamentals.org/webgl/lessons/webgl-image-processing.html" target="_blank" rel="external">the image processing examples</a><br>you’ll see they also use an extra attribute to pass in texture coordinates.</p>
</blockquote>
<p>我猜这可能不是那么有趣，但是这至少证明了可以从顶点着色器向片元着色器传递多个属性数据。如果你看过<a href="http://webglfundamentals.org/webgl/lessons/webgl-image-processing.html" target="_blank" rel="external">图片处理的例子</a>，你就会发现那些例子其实也是使用额外的属性来传入纹理坐标的。</p>
<blockquote>
<h2 id="What_do_these_buffer_and_attibute_commands_do?">What do these buffer and attibute commands do?</h2><h2 id="上面这些缓冲和属性命令的作用是什么？">上面这些缓冲和属性命令的作用是什么？</h2><p>Buffers are the way of getting vertex and other per vertex data onto the<br>GPU.  <code>gl.createBuffer</code> creates a buffer.<br><code>gl.bindBuffer</code> sets that buffer as the buffer to be worked on.<br><code>gl.bufferData</code> copies data into the buffer.</p>
</blockquote>
<p>缓冲去对象用来存储顶点和相关数据。<code>gl.createBuffer</code> 方法用来创建缓冲区对象。<code>gl.bindBuffer</code> 设置缓冲区对象为工作对象。<code>gl.bufferData</code> 将数据放入缓冲区对象。</p>
<blockquote>
<p>Once the data is in the buffer we need to tell WebGL how to get data out<br>of it and provide it to the vertex shader’s attributes.</p>
</blockquote>
<p>当缓冲区对象中存入数据后，我们需要告诉 WebGL 获取数据并把这些数据提供给顶点着色器的属性。</p>
<blockquote>
<p>To do this, first we ask WebGL what locations it assigned to the<br>attributes.  For example in the code above we have</p>
</blockquote>
<p>为了做到这点，我们首先需要获取到 WebGL 分配给这些属性的地址。拿上面的代码举例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// look up where the vertex data needs to go.</span></span><br><span class="line"><span class="keyword">var</span> positionLocation = gl.getAttribLocation(program, <span class="string">"a_position"</span>);</span><br><span class="line"><span class="keyword">var</span> colorLocation = gl.getAttribLocation(program, <span class="string">"a_color"</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Once we know the location of the attribute we then issue 2 commands.</p>
</blockquote>
<p>一旦我们知道属性的地址就可以执行下面2个命令。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gl.enableVertexAttribArray(location);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>This command tells WebGL we want to supply data from a buffer.</p>
</blockquote>
<p>这条命令告诉 WebGL 我们相处缓冲对象中获取数据。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gl.vertexAttribPointer(</span><br><span class="line">    location,</span><br><span class="line">    numComponents,</span><br><span class="line">    typeOfData,</span><br><span class="line">    normalizeFlag,</span><br><span class="line">    strideToNextPieceOfData,</span><br><span class="line">    offsetIntoBuffer);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>And this command tells WebGL to get data from the buffer that was last<br>bound with gl.bindBuffer, how many components per vertex (1 - 4), what the<br>type of data is (<code>BYTE</code>, <code>FLOAT</code>, <code>INT</code>, <code>UNSIGNED_SHORT</code>, etc…), the stride<br>which means how many bytes to skip to get from one piece of data to the<br>next piece of data, and an offset for how far into the buffer our data is.</p>
</blockquote>
<p>这条命令告诉 WebGL 从缓冲区对象中将数据分配出去。numComponents 指定缓冲区中每个顶点的分量个数（1到4）。typeOfData 表示数据格式(<code>BYTE</code>, <code>FLOAT</code>, <code>INT</code>, <code>UNSIGNED_SHORT</code>等)。strideToNextPieceOfData 表示相邻两个顶点间的字节数。offsetIntoBuffer 指定缓冲区对象中的偏移量。</p>
<blockquote>
<p>Number of components is always 1 to 4.</p>
</blockquote>
<p>再次提醒下，缓冲区中的分量个数范围为 1 到 4。</p>
<blockquote>
<p>If you are using 1 buffer per type of data then both stride and offset can<br>always be 0.  0 for stride means “use a stride that matches the type and<br>size”.  0 for offset means start at the beginning of the buffer.  Setting<br>them to values other than 0 is more complicated and though it has some<br>benefits in terms of performance it’s not worth the complication unless<br>you are trying to push WebGL to its absolute limits.</p>
</blockquote>
<p>如果每中类型的数据只使用了一个缓冲区对象，那么 stride 和 offset 都为 0。0对于 stride 意味着“使用符合类型大小的 stride”。0对于 offset 意味着起点在缓冲开始位置。如果设置为其他非0值，可能会让情况变得复杂，但是一般这么做是处于性能优化的目的。一般情况下，这种做法是值得尝试的。</p>
<blockquote>
<p>I hope that clears up buffers and attributes.</p>
</blockquote>
<p>最后记得清理缓冲和属性值。</p>
<blockquote>
<p>Next let’s go over <a href="http://webglfundamentals.org/webgl/lessons/webgl-shaders-and-glsl.html" target="_blank" rel="external">shaders and GLSL</a>.</p>
</blockquote>
<p>下一章节，我们将会学习<a href="http://webglfundamentals.org/webgl/lessons/webgl-shaders-and-glsl.html" target="_blank" rel="external">着色器和 GLSL</a>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文地址：<a href="http://webglfundamentals.org/webgl/lessons/webgl-how-it-works.html">http://webglfundamentals.org/webgl/lessons/webgl-how-it-works.html</a></p>
<p><img src="http://7tt058.com1.z0.glb.clouddn.com/webgl-fixed-unctionality.gif" alt="webgl 流水线"></p>
<blockquote>
<p>This is a continuation from <a href="webgl-fundamentals.html">WebGL Fundamentals</a>.<br>Before we continue I think we need to discuss at a<br>basic level what WebGL and your GPU actually do.  There are basically 2<br>parts to this GPU thing.  The first part processes vertices (or streams of<br>data) into clipspace vertices.  The second part draws pixels based on the<br>first part.</p>
</blockquote>
<p>本文是上一章节<a href="http://webglfundamentals.org/webgl/lessons/webgl-fundamentals.html">WebGL 基本原理</a>内容的延续。开始之前，我认为我们应该先理解 WebGL 和 GPU 在底层上的工作机制。GPU 其实主要处理两方面的事情，首先把顶点信息（或数据流）处理成 WebGL 空间中的顶点，然后再次基础上，逐像素绘制图形。</p>]]>
    
    </summary>
    
      <category term="webgl" scheme="http://reygreen1.github.io/tags/webgl/"/>
    
      <category term="webgl" scheme="http://reygreen1.github.io/categories/webgl/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]WebGL 基础系列：WebGL 基本原理]]></title>
    <link href="http://reygreen1.github.io/2015/10/24/webgl-fundamentals/"/>
    <id>http://reygreen1.github.io/2015/10/24/webgl-fundamentals/</id>
    <published>2015-10-23T16:00:00.000Z</published>
    <updated>2015-11-03T05:59:25.000Z</updated>
    <content type="html"><![CDATA[<p>原文地址：<a href="http://webglfundamentals.org/webgl/lessons/webgl-fundamentals.html" target="_blank" rel="external">http://webglfundamentals.org/webgl/lessons/webgl-fundamentals.html</a></p>
<p><img src="http://7tt058.com1.z0.glb.clouddn.com/webgl-fundation.jpg" alt="WebGL 架构"></p>
<blockquote>
<p>WebGL makes it possible to display amazing realtime 3D graphics in your<br>browser but what many people don’t know is that<br><a href="webgl-2d-vs-3d-library.html">WebGL is actually a rasterization API, not a 3D API</a>.</p>
</blockquote>
<p>WebGL 让你在浏览器中可以渲染出令人惊叹的 3D 图形效果，但是大多数人都不知道<a href="http://webglfundamentals.org/webgl/lessons/webgl-2d-vs-3d-library.html" target="_blank" rel="external">WebGL 其实只是光栅化 API ，而不是 3D API</a>。</p>
<blockquote>
<p>Let me explain.</p>
</blockquote>
<p>下面我来详细解释下。</p>
<a id="more"></a>
<blockquote>
<p>WebGL only cares about 2 things. Clipspace coordinates and colors.<br>Your job as a programmer using WebGL is to provide WebGL with those 2 things.<br>You provide 2 “shaders” to do this. A Vertex shader which provides the<br>clipspace coordinates and a fragment shader that provides the color.</p>
</blockquote>
<p>WebGL 只关心2件事情：空间坐标和颜色。作为 WebGL 的开发者，你的工作就是把这2个信息提供给 WebGL。具体做法就是使用2种着色器：顶点着色器和片元着色器。顶点着色器包含了空间坐标信息，片元着色器包含了颜色信息。</p>
<blockquote>
<p>Clipspace coordinates always go from -1 to +1 no matter what size your<br>canvas is. Here is a simple WebGL example that shows WebGL in its simplest form.</p>
</blockquote>
<p>需要注意，在 WebGL 中，无论 canvas 有多大，空间坐标系的坐标范围都是[-1, 1]。<br>下面的代码是一个简单的例子，展示了 WebGL 编程的基本流程。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 WebGL 上下文</span></span><br><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">"canvas"</span>);</span><br><span class="line"><span class="keyword">var</span> gl = canvas.getContext(<span class="string">"experimental-webgl"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 GLSL 程序</span></span><br><span class="line"><span class="keyword">var</span> program = createProgramFromScripts(gl, [<span class="string">"2d-vertex-shader"</span>, <span class="string">"2d-fragment-shader"</span>]);</span><br><span class="line">gl.useProgram(program);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定顶点数据</span></span><br><span class="line"><span class="keyword">var</span> positionLocation = gl.getAttribLocation(program, <span class="string">"a_position"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建缓存对象，并把矩形的顶点坐标放入缓存对象</span></span><br><span class="line"><span class="keyword">var</span> buffer = gl.createBuffer();</span><br><span class="line">gl.bindBuffer(gl.ARRAY_BUFFER, buffer);</span><br><span class="line">gl.bufferData(</span><br><span class="line">    gl.ARRAY_BUFFER,</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Float32Array</span>([</span><br><span class="line">        -<span class="number">1.0</span>, -<span class="number">1.0</span>,</span><br><span class="line">         <span class="number">1.0</span>, -<span class="number">1.0</span>,</span><br><span class="line">        -<span class="number">1.0</span>,  <span class="number">1.0</span>,</span><br><span class="line">        -<span class="number">1.0</span>,  <span class="number">1.0</span>,</span><br><span class="line">         <span class="number">1.0</span>, -<span class="number">1.0</span>,</span><br><span class="line">         <span class="number">1.0</span>,  <span class="number">1.0</span>]),</span><br><span class="line">    gl.STATIC_DRAW);</span><br><span class="line">gl.enableVertexAttribArray(positionLocation);</span><br><span class="line">gl.vertexAttribPointer(positionLocation, <span class="number">2</span>, gl.FLOAT, <span class="literal">false</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制图形</span></span><br><span class="line">gl.drawArrays(gl.TRIANGLES, <span class="number">0</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Here’s the 2 shaders</p>
</blockquote>
<p>着色器代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script id="2d-vertex-shader" type="x-shader/x-vertex"&gt;</span><br><span class="line">attribute vec2 a_position;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">  gl_Position = vec4(a_position, 0, 1);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script id="2d-fragment-shader" type="x-shader/x-fragment"&gt;</span><br><span class="line">void main() &#123;</span><br><span class="line">  gl_FragColor = vec4(0, 1, 0, 1);  // green</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>This will draw a green rectangle the entire size of the canvas. Here it is</p>
</blockquote>
<p>上面的代码会在 canvas 上画一个绿色的矩形。示例如下：</p>
<iframe class="webgl_example" style="width: 400px; height: 300px;" src="http://webglfundamentals.org/webgl/webgl-fundamentals.html"></iframe>

<blockquote>
<p>Not very exciting :-p</p>
</blockquote>
<p>看起来似乎并不是很令人兴奋。</p>
<blockquote>
<p>Again, clipspace coordinates always go from -1 to +1 regardless of the<br>size of the canvas. In the case above you can see we are doing nothing<br>but passing on our position data directly. Since the position data is<br>already in clipspace there is no work to do. <em>If you want 3D it’s up to you<br>to supply shaders that convert from 3D to clipspace because WebGL is only<br>a rasterization API</em>.</p>
</blockquote>
<p>再次提醒下，空间坐标范围永远都是[-1, 1]，而不受 canvas 大小影响。从上面的例子看出，我们其实没做任何事情，只是把位置数据传递了过去。这是因为这些位置数据已经是符合要求的坐标数据。<em>如果你想实现 3D 效果，那么你需要将 3D 数据转换为 WebGL 坐标数据给着色器，因为 WebGL 只是光栅化 API</em>。</p>
<blockquote>
<p>For 2D stuff you would probably rather work in pixels than clipspace so<br>let’s change the shader so we can supply rectangles in pixels and have<br>it convert to clipspace for us. Here’s the new vertex shader</p>
</blockquote>
<p>对于 2D 开发者，更多时间会同像素打交道而非这里的空间坐标。因此，我们这里需要修改下着色器，当我们传递的是像素信息时，它能自动为我们转换成合适的空间坐标。下面是新的顶点着色器：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;script id=<span class="string">"2d-vertex-shader"</span> type=<span class="string">"x-shader/x-vertex"</span>&gt;</span><br><span class="line">attribute vec2 a_position;</span><br><span class="line"></span><br><span class="line">uniform vec2 u_resolution;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">   <span class="comment">// convert the rectangle from pixels to 0.0 to 1.0</span></span><br><span class="line">   vec2 zeroToOne = a_position / u_resolution;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// convert from 0-&gt;1 to 0-&gt;2</span></span><br><span class="line">   vec2 zeroToTwo = zeroToOne * <span class="number">2.0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// convert from 0-&gt;2 to -1-&gt;+1 (clipspace)</span></span><br><span class="line">   vec2 clipSpace = zeroToTwo - <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">   gl_Position = vec4(clipSpace, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Now we can change our data from clipspace to pixels</p>
</blockquote>
<p>现在我们可以把数据直接从空间坐标修改为像素值了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// set the resolution</span></span><br><span class="line"><span class="keyword">var</span> resolutionLocation = gl.getUniformLocation(program, <span class="string">"u_resolution"</span>);</span><br><span class="line">gl.uniform2f(resolutionLocation, canvas.width, canvas.height);</span><br><span class="line"></span><br><span class="line"><span class="comment">// setup a rectangle from 10,20 to 80,30 in pixels</span></span><br><span class="line">gl.bufferData(gl.ARRAY_BUFFER, <span class="keyword">new</span> <span class="built_in">Float32Array</span>([</span><br><span class="line">    <span class="number">10</span>, <span class="number">20</span>,</span><br><span class="line">    <span class="number">80</span>, <span class="number">20</span>,</span><br><span class="line">    <span class="number">10</span>, <span class="number">30</span>,</span><br><span class="line">    <span class="number">10</span>, <span class="number">30</span>,</span><br><span class="line">    <span class="number">80</span>, <span class="number">20</span>,</span><br><span class="line">    <span class="number">80</span>, <span class="number">30</span>]), gl.STATIC_DRAW);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>And here it is</p>
</blockquote>
<p>示例如下：</p>
<iframe class="webgl_example" style="width: 400px; height: 300px;" src="http://webglfundamentals.org/webgl/webgl-2d-rectangle.html"></iframe>

<blockquote>
<p>You might notice the rectangle is near the bottom of that area. WebGL considers the bottom left<br>corner to be 0,0. To get it to be the more traditional top left corner used for 2d graphics APIs<br>we just flip the y coordinate.</p>
</blockquote>
<p>你可能已经注意到了矩形位于区域的左下角，WebGL 将左下角坐标设置为（0,0）。而在 2d 图形 API 中均把左上角看做原点。为了符合这样的习惯，我们只需翻转下 y 轴坐标即可。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gl_Position = vec4(clipSpace * vec2(<span class="number">1</span>, -<span class="number">1</span>), <span class="number">0</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>And now our rectangle is where we expect it.</p>
</blockquote>
<p>现在矩形就显示在了我们期望的位置上。</p>
<iframe class="webgl_example" style="width: 400px; height: 300px;" src="http://webglfundamentals.org/webgl/webgl-2d-rectangle-top-left.html"></iframe>

<blockquote>
<p>Let’s make the code that defines a rectangle into a function so<br>we can call it for different sized rectangles. While we’re at it<br>we’ll make the color settable.</p>
</blockquote>
<p>现在我们修改下代码，将定义矩形的代码放入函数，这样每次调用函数都可以得到不同大小的矩形。同时，我们用变量来存储颜色值。</p>
<blockquote>
<p>First we make the fragment shader take a color uniform input.</p>
</blockquote>
<p>首先，我们在片元着色器中设置一个 uniform 类型的变量来存储颜色值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script id=<span class="string">"2d-fragment-shader"</span> type=<span class="string">"x-shader/x-fragment"</span>&gt;</span><br><span class="line">precision mediump float;</span><br><span class="line"></span><br><span class="line">uniform vec4 u_color;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">    gl_FragColor = u_color;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>And here’s the new code that draws 50 rectangles in random places and random colors.</p>
</blockquote>
<p>下面的新代码绘制了50个矩形，每个矩形都有随机的位置和颜色。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">var</span> colorLocation = gl.getUniformLocation(program, <span class="string">"u_color"</span>);</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 创建缓存对象</span></span><br><span class="line">  <span class="keyword">var</span> buffer = gl.createBuffer();</span><br><span class="line">  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);</span><br><span class="line">  gl.enableVertexAttribArray(positionLocation);</span><br><span class="line">  gl.vertexAttribPointer(positionLocation, <span class="number">2</span>, gl.FLOAT, <span class="literal">false</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 绘制50个随机位置和颜色的矩形</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> ii = <span class="number">0</span>; ii &lt; <span class="number">50</span>; ++ii) &#123;</span><br><span class="line">    <span class="comment">// 随机产生一个位置</span></span><br><span class="line">    setRectangle(</span><br><span class="line">        gl, randomInt(<span class="number">300</span>), randomInt(<span class="number">300</span>), randomInt(<span class="number">300</span>), randomInt(<span class="number">300</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随机产生一个颜色</span></span><br><span class="line">    gl.uniform4f(colorLocation, <span class="built_in">Math</span>.random(), <span class="built_in">Math</span>.random(), <span class="built_in">Math</span>.random(), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制矩形</span></span><br><span class="line">    gl.drawArrays(gl.TRIANGLES, <span class="number">0</span>, <span class="number">6</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机返回0或-1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomInt</span><span class="params">(range)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * range);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将一个矩形的相关信息放入缓存对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setRectangle</span><span class="params">(gl, x, y, width, height)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x1 = x;</span><br><span class="line">  <span class="keyword">var</span> x2 = x + width;</span><br><span class="line">  <span class="keyword">var</span> y1 = y;</span><br><span class="line">  <span class="keyword">var</span> y2 = y + height;</span><br><span class="line">  gl.bufferData(gl.ARRAY_BUFFER, <span class="keyword">new</span> <span class="built_in">Float32Array</span>([</span><br><span class="line">     x1, y1,</span><br><span class="line">     x2, y1,</span><br><span class="line">     x1, y2,</span><br><span class="line">     x1, y2,</span><br><span class="line">     x2, y1,</span><br><span class="line">     x2, y2]), gl.STATIC_DRAW);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>And here’s the rectangles.</p>
</blockquote>
<p>下面的示例展示了这些矩形效果：</p>
<iframe class="webgl_example" style="width: 400px; height: 300px;" src="http://webglfundamentals.org/webgl/webgl-2d-rectangles.html"></iframe>

<blockquote>
<p>I hope you can see that WebGL is actually a pretty simple API.<br>While it can get more complicated to do 3D that complication is<br>added by you, the programmer, in the form of more complex shaders.<br>The WebGL API itself is 2D and fairly simple.</p>
</blockquote>
<p>我希望你能认识到，WebGL 本身的 API 非常简单。但当它处理 3D 效果时又变得非常复杂。这种复杂性完全是由开发者自己提升上去的，因为在开发过程中使用了很多复杂的着色器。WebGL API 本身是 2D 的，并且非常简单。</p>
<blockquote>
<p>If you’re 100% new to WebGL and have no idea what GLSL is or shaders or what the GPU does<br>then checkout <a href="webgl-how-it-works.html">the basics of how WebGL really works</a>.</p>
</blockquote>
<p>如果你完全不了解 WegGL，不知道 GLSL 和着色器，也不明白 GPU 是做什么的，那么你可以先去看看<a href="http://webglfundamentals.org/webgl/lessons/webgl-how-it-works.html" target="_blank" rel="external">WebGL 工作的基本原理</a>。</p>
<blockquote>
<p>Otherwise from here you can go in 2 directions. If you are interested in image procesing<br>I’ll show you <a href="http://webglfundamentals.org/webgl/lessons/webgl-image-processing.html" target="_blank" rel="external">how to do some 2D image processing</a>.<br>If you are interesting in learning about translation,<br>rotation and scale then <a href="http://webglfundamentals.org/webgl/lessons/webgl-2d-translation.html" target="_blank" rel="external">start here</a>.</p>
</blockquote>
<p>从这里开始，你有两个方向可以选择。如果你对图像处理感兴趣，可以先看看<a href="http://webglfundamentals.org/webgl/lessons/webgl-image-processing.html" target="_blank" rel="external">如何处理 2D 图像</a>。如果你对学习变换、旋转和缩放感兴趣，那么可以看看<a href="http://webglfundamentals.org/webgl/lessons/webgl-2d-translation.html" target="_blank" rel="external">WebGL 2D 变换</a>。</p>
<hr>
<h3 id="type=”x-shader/x-vertex”_和_type=”x-shader/x-fragment”_的作用是什么？">type=”x-shader/x-vertex” 和 type=”x-shader/x-fragment” 的作用是什么？</h3><blockquote>
<p><code>&lt;script&gt;</code> tags default to having JavaScript in them. You can put no type or you can put type=”javascript” or type=”text/javascript” and the browser will interpret the contents as JavaScript. If you put anything else the browser ignores the contents of the script tag.</p>
</blockquote>
<p><code>&lt;script&gt;</code> 标签默认情况下里面包含了 JavaScript 代码。你可以通过设置 type 的值来让浏览器正确处理里面的 JavaScript 代码。如果你设置的是其他值，那么浏览器就会忽略处理标签内的内容。</p>
<blockquote>
<p>We can use this feature to store shaders in script tags. Even better, we can make up our own type and in our javascript look for that to decide whether to compile the shader as a vertex shader or a fragment shader.</p>
</blockquote>
<p>我们可以使用这个特性在 script 标签中存储着色器代码。甚至，我们还可以自定义 type 类型，从而告诉后续的编译器将着色器代码编译为顶点着色器还是片元着色器。</p>
<blockquote>
<p>In this case the function createProgramFromScripts looks for scripts with specified ids and then looks at the type to decide what type of shader to create.</p>
</blockquote>
<p>在上面的例子中，<code>createProgramFromScripts</code> 方法通过特殊id来查找 script 标签，然后根据 type 值来创建不同类型的着色器。</p>
<blockquote>
<p>createProgramFromScripts is part of some boilerplate like code that almost every WebGL program needs.</p>
</blockquote>
<p>所有 WebGL 程序需要 <code>createProgramFromScripts</code> 方法，可参考<a href="http://webglfundamentals.org/webgl/lessons/webgl-boilerplate.html" target="_blank" rel="external">WebGL Boilerplate</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文地址：<a href="http://webglfundamentals.org/webgl/lessons/webgl-fundamentals.html">http://webglfundamentals.org/webgl/lessons/webgl-fundamentals.html</a></p>
<p><img src="http://7tt058.com1.z0.glb.clouddn.com/webgl-fundation.jpg" alt="WebGL 架构"></p>
<blockquote>
<p>WebGL makes it possible to display amazing realtime 3D graphics in your<br>browser but what many people don’t know is that<br><a href="webgl-2d-vs-3d-library.html">WebGL is actually a rasterization API, not a 3D API</a>.</p>
</blockquote>
<p>WebGL 让你在浏览器中可以渲染出令人惊叹的 3D 图形效果，但是大多数人都不知道<a href="http://webglfundamentals.org/webgl/lessons/webgl-2d-vs-3d-library.html">WebGL 其实只是光栅化 API ，而不是 3D API</a>。</p>
<blockquote>
<p>Let me explain.</p>
</blockquote>
<p>下面我来详细解释下。</p>]]>
    
    </summary>
    
      <category term="webgl" scheme="http://reygreen1.github.io/tags/webgl/"/>
    
      <category term="webgl" scheme="http://reygreen1.github.io/categories/webgl/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]WebGL 基础系列：前言]]></title>
    <link href="http://reygreen1.github.io/2015/10/23/webgl-fundamentals-introduction/"/>
    <id>http://reygreen1.github.io/2015/10/23/webgl-fundamentals-introduction/</id>
    <published>2015-10-22T16:00:00.000Z</published>
    <updated>2015-11-03T05:56:09.000Z</updated>
    <content type="html"><![CDATA[<p>原文地址：<a href="http://webglfundamentals.org/" target="_blank" rel="external">http://webglfundamentals.org/</a></p>
<p><img src="http://7tt058.com1.z0.glb.clouddn.com/webgl-introduction.jpg" alt="WebGL fundamentals"></p>
<blockquote>
<p>WebGL from the ground up. No magic.</p>
</blockquote>
<p>WebGL 并不复杂难懂。</p>
<blockquote>
<p>These are a set of articles that teach WebGL from basic principles. They are NOT old rehashed out of date OpenGL articles like many others on the net. They are entirely new, discarding the old out of date ideas and bringing you to a full understanding of what WebGL really is and how it really works.</p>
</blockquote>
<p>这个教程集合了一系列从基本概念来介绍 WebGL 的文章。但是，这些文章同网络上其他介绍 OpenGL 的文章完全不同。它们抛弃了那些过时的想法，取而代之的是，用一种全新的方式来帮助你全面理解 WebGL 的概念和工作原理　。 </p>
<a id="more"></a>
<h2 id="文章目录：">文章目录：</h2><h3 id="基本原理">基本原理</h3><ul>
<li>WebGL Fundamentals : WebGL 基本原理</li>
<li>WebGL How It Works ： WebGL 工作机制</li>
<li>WebGL Shaders and GLSL：WebGL 着色器和 GLSL</li>
</ul>
<h3 id="图像处理">图像处理</h3><ul>
<li>WebGL Image Processing : WebGL 图像处理</li>
<li>WebGL Image Processing Continued : WebGL 图像处理后续</li>
</ul>
<h3 id="2D_变换、旋转、缩放、矩阵运算">2D 变换、旋转、缩放、矩阵运算</h3><ul>
<li>WebGL 2D Translation : WebGL 2D 变换</li>
<li>WebGL 2D Rotation : WebGL 2D 旋转</li>
<li>WebGL 2D Scale : WebGL 2D 缩放</li>
<li>WebGL 2D Matrices : WebGL 2D 矩阵变换</li>
</ul>
<h3 id="3D">3D</h3><ul>
<li>WebGL - Orthographic 3D : WebGL - 正交 3D</li>
<li>WebGL 3D Perspective : WebGL 3D 视角</li>
<li>WebGL 3D - Cameras : WebGL 3D - 摄像头</li>
</ul>
<h3 id="Structure_and_Organization_组织结构">Structure and Organization 组织结构</h3><ul>
<li>WebGL - Less Code, More Fun : WebGL - 简洁高效</li>
<li>WebGL - Drawing Multiple Things : WebGL - 绘制多个图形</li>
<li>WebGL - Scene Graphs : WebGL - 场景图形</li>
</ul>
<h3 id="文本">文本</h3><ul>
<li>WebGL Text - HTML : WebGL 文本 - HTML</li>
<li>WebGL Text - Canvas 2D</li>
<li>WebGL Text - Using a Texture : WebGL Text - 使用纹理</li>
<li>WebGL Text - Using a Glyph Texture : WebGL Text - 使用图形纹理</li>
</ul>
<h3 id="混合">混合</h3><ul>
<li>WebGL Boilerplate : WebGL 模板文件</li>
<li>WebGL Resizing the Canvas : WebGL 缩放 Canvas</li>
<li>WebGL - Animation : WebGL - 动画</li>
<li>WebGL 3D - Textures : WebGL 3D - 纹理</li>
<li>WebGL Using 2 or More Textures : WebGL 使用2个或更多纹理</li>
<li>WebGL and Alpha : WebGL 与透明度</li>
<li>WebGL - 2D vs 3D libraries : WebGL - 2D vs 3D 库</li>
<li>WebGL - Anti-Patterns : WebGL - 反模式</li>
</ul>
<h3 id="其他">其他</h3><ul>
<li>Helper API Docs : API 帮助文档</li>
<li>TWGL, A tiny WebGL helper library : <a href="http://twgljs.org" target="_blank" rel="external">TWGL, 一个轻量级的 WebGL 库</a></li>
<li><a href="https://github.com/greggman/webgl-fundamentals" target="_blank" rel="external">github</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文地址：<a href="http://webglfundamentals.org/">http://webglfundamentals.org/</a></p>
<p><img src="http://7tt058.com1.z0.glb.clouddn.com/webgl-introduction.jpg" alt="WebGL fundamentals"></p>
<blockquote>
<p>WebGL from the ground up. No magic.</p>
</blockquote>
<p>WebGL 并不复杂难懂。</p>
<blockquote>
<p>These are a set of articles that teach WebGL from basic principles. They are NOT old rehashed out of date OpenGL articles like many others on the net. They are entirely new, discarding the old out of date ideas and bringing you to a full understanding of what WebGL really is and how it really works.</p>
</blockquote>
<p>这个教程集合了一系列从基本概念来介绍 WebGL 的文章。但是，这些文章同网络上其他介绍 OpenGL 的文章完全不同。它们抛弃了那些过时的想法，取而代之的是，用一种全新的方式来帮助你全面理解 WebGL 的概念和工作原理　。 </p>]]>
    
    </summary>
    
      <category term="webgl" scheme="http://reygreen1.github.io/tags/webgl/"/>
    
      <category term="webgl" scheme="http://reygreen1.github.io/categories/webgl/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[前端基础课：跨域]]></title>
    <link href="http://reygreen1.github.io/2015/10/21/cross-domain/"/>
    <id>http://reygreen1.github.io/2015/10/21/cross-domain/</id>
    <published>2015-10-20T16:00:00.000Z</published>
    <updated>2015-10-26T06:37:46.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://7tt058.com1.z0.glb.clouddn.com/bridge.jpg" alt="金门大桥"></p>
<p>待后续整理。。。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://7tt058.com1.z0.glb.clouddn.com/bridge.jpg" alt="金门大桥"></p>
<p>待后续整理。。。</p>
]]>
    </summary>
    
      <category term="跨域" scheme="http://reygreen1.github.io/tags/%E8%B7%A8%E5%9F%9F/"/>
    
      <category term="基础课" scheme="http://reygreen1.github.io/categories/%E5%9F%BA%E7%A1%80%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[SVG 入门指南]]></title>
    <link href="http://reygreen1.github.io/2015/09/22/svg-introduction/"/>
    <id>http://reygreen1.github.io/2015/09/22/svg-introduction/</id>
    <published>2015-09-21T16:00:00.000Z</published>
    <updated>2015-09-22T11:05:54.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://7tt058.com1.z0.glb.clouddn.com/svg.png" alt="svg"></p>
<p>SVG 是可缩放矢量图形（Scalable Vector Graphics，SVG），是一种描述二位矢量图形的 XML 标记语言。</p>
<p>百科中对 SVG 的说明：</p>
<blockquote>
<ol>
<li>SVG 指可伸缩矢量图形 (Scalable Vector Graphics)</li>
<li>SVG 用来定义用于网络的基于矢量的图形</li>
<li>SVG 使用 XML 格式定义图形</li>
<li>SVG 图像在放大或改变尺寸的情况下其图形质量不会有所损失</li>
<li>SVG 是万维网联盟的标准</li>
<li>SVG 与诸如 DOM 和 XSL 之类的 W3C 标准是一个整体</li>
</ol>
</blockquote>
<p>SVG 和 Canvas 是 HTML5 中主要的 2D 图形相关技术。一方面，在 HTML5 发展的大环境下，SVG 有很好的机遇。另一方面，它的主要对手是 flash，同 flash 相比，它与很多标准（如 XSL 和 DOM 等）相兼容，而 flash 是非开源的私有技术。所以，如此看来，SVG 在未来的图形开发中必将占据重要的一席之地。</p>
<a id="more"></a>
<h2 id="到底选择_Canvas_还是_SVG_？">到底选择 Canvas 还是 SVG ？</h2><p>既然两者都是 HTML5 中的图形技术，那么到底该选择哪个来解决问题呢？</p>
<p>解决问题应该注意实际场景，然后根据技术特点来进行选型。所以，我们先来比较下两者的主要特点：</p>
<p><img src="http://7tt058.com1.z0.glb.clouddn.com/canvas_svg.jpg" alt="Canvas VS SVG 1"></p>
<p><img src="http://7tt058.com1.z0.glb.clouddn.com/Canvas_Vs_SVG2.png" alt="Canvas VS SVG 2"></p>
<p>根据它们的不同特点，我们可以分析出各自的适用场景：</p>
<p><strong>Canvas 适合像素处理、动态渲染和大数据量绘制的场景。</strong></p>
<p><strong>SVG 适合静态图片展示、高保真文档查看和打印的场景。</strong></p>
<p>所以，选择哪种技术，可以具体分析下业务场景。</p>
<h2 id="基本知识">基本知识</h2><p>这篇文章是入门指南，非入门教程，不会对 SVG 的基础知识做详细介绍，只会对涉及的功能做简单描述。如果想了解具体的基础知识点，可以参考 MDN 上的文章：<a href="https://developer.mozilla.org/zh-CN/docs/Web/SVG" target="_blank" rel="external">SVG</a>。</p>
<p><strong>SVG 形状</strong>：提供了矩形（rect）、圆形（circle）、椭圆（ellipse）、线条（line）、多边形（polygon）、折线（polyline）、文本（text）等绘图接口。还有一个非常重要的功能：路径（path），后面会重点介绍。</p>
<p><strong>SVG 滤镜</strong>：</p>
<ul>
<li>feBlend</li>
<li>feColorMatrix</li>
<li>feComponentTransfer</li>
<li>feComposite</li>
<li>feConvolveMatrix</li>
<li>feDiffuseLighting</li>
<li>feDisplacementMap</li>
<li>feFlood</li>
<li>feGaussianBlur</li>
<li>feImage</li>
<li>feMerge</li>
<li>feMorphology</li>
<li>feOffset</li>
<li>feSpecularLighting</li>
<li>feTile</li>
<li>feTurbulence</li>
<li>feDistantLight</li>
<li>fePointLight</li>
<li>feSpotLight</li>
</ul>
<p><strong>SVG 渐变</strong>：线性渐变（linearGradient）、放射性渐变（radialGradient）</p>
<h2 id="路径（path）">路径（path）</h2><p>路径（path）在 SVG 中是非常重要的概念，有人曾这样说，了解了 path 也就基本学会了 SVG 80%的知识。</p>
<p>路径包含了下面一些命令：</p>
<ul>
<li>M = move to 移动到</li>
<li>L = line to 当前节点到指定(x,y)节点，直线连接</li>
<li>H = horizontal line to 保持当前点的y坐标不变，x轴移动到x，形成水平线</li>
<li>V = vertical line to 保持当前点的x坐标不变，y轴移动到y，形成垂直线</li>
<li>C = curve to 三次贝塞尔曲线</li>
<li>S = smooth curve to 平滑三次贝塞尔曲线</li>
<li>Q = quadratic Bézier curve 二次贝塞尔曲线</li>
<li>T = smooth quadratic Bézier curveto 平滑二次贝塞尔曲线 </li>
<li>A = elliptical Arc 弧形</li>
<li>Z = close path 将路径的开始和结束点用直线连接</li>
</ul>
<p>使用这些命令可以创建出各种复杂的图形。具体每个命令的用法可以参考 MDN 中的相关介绍。</p>
<h2 id="SVG_生成工具">SVG 生成工具</h2><p>从上面介绍可以看出，简单的图形通过 SVG 的接口方便创建，但是遇到复杂的图形，工作将会变得非常复杂，各种命令的使用也会严重降低开发效率。所以，我们可以通过工具来生成复杂的 SVG 图像。</p>
<p><strong><a href="https://code.google.com/p/svg-edit/" target="_blank" rel="external">Google 的 SVG 编辑器</a></strong> 或者也可以使用<a href="http://www.zhangxinxu.com/" target="_blank" rel="external">张鑫旭</a>自己网站上的<a href="http://www.zhangxinxu.com/sp/svg/" target="_blank" rel="external">在线编辑器</a>。</p>
<p>另一个工具是，专业的图形设计软件、矢量绘制软件 — <a href="http://www.adobe.com/cn/products/illustrator.html" target="_blank" rel="external">Adobe Illustrator</a>。</p>
<p><img src="http://7tt058.com1.z0.glb.clouddn.com/ai.jpg" alt="AI"></p>
<h2 id="SVG_类库与框架">SVG 类库与框架</h2><p>写过 SVG 都会发现，直接使用各种命令在创建复杂的图形和交互的时候非常麻烦，所以各种类库和框架就应运而生，旨在提高开发效率。</p>
<h3 id="Snap-svg">Snap.svg</h3><p><img src="http://7tt058.com1.z0.glb.clouddn.com/Snap.svg-images.png" alt="Snap.svg"></p>
<p><a href="http://snapsvg.io/" target="_blank" rel="external">Snap.svg</a> 是为高级浏览器设计的类库，它号称：</p>
<blockquote>
<p>And the Snap.svg JavaScript library makes working with your SVG assets as easy as jQuery makes working with the DOM.</p>
</blockquote>
<p>上文是说，<strong>使用 Snap.svg 来操作 SVG 就像使用 jQuery 操作 DOM 一样简单高效</strong>。</p>
<p><a href="https://github.com/adobe-webplatform/Snap.svg" target="_blank" rel="external">Github项目主页</a>，已经有 7000 多个 star。</p>
<p>Snap 的中文 API 文档可以参考这里：<a href="http://www.zhangxinxu.com/GitHub/demo-Snap.svg/demo/basic/" target="_blank" rel="external">Snap.svg API中文文档</a>。</p>
<h3 id="Raphael">Raphael</h3><p>Raphael 是另一个可选择的 SVG 库。</p>
<p><img src="http://7tt058.com1.z0.glb.clouddn.com/svg-raphael.jpg" alt="Raphael.js"></p>
<p>可以这么理解 Raphael ，它和 Snap.svg 是同一个作者写的，只是兼容性降低到了 IE6，同时做的兼容性工作导致文件也比较大，<strong>未压缩版本 299Kb，压缩版本也有 91Kb</strong>。使用时需要特别注意。</p>
<p><a href="http://raphaeljs.com" target="_blank" rel="external">Raphael</a>的相关 API 可以参考这里：<a href="http://raphaeljs.com/reference.html" target="_blank" rel="external">Raphael 文档参考</a>。</p>
<h2 id="实例">实例</h2><p>针对上一篇文章中的圆形进度条，这里做了一个 Snap.js 版本的 Demo:</p>
<iframe height="268" scrolling="no" src="//codepen.io/reygreen1/embed/xwOdPb/?height=268&theme-id=18663&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/reygreen1/pen/xwOdPb/" target="_blank" rel="external">svg circle progress</a> by reygreen1 (<a href="http://codepen.io/reygreen1" target="_blank" rel="external">@reygreen1</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.<br></iframe>

<p>可参考相关源码，用后感觉确实非常简单方便，需要兼容低版本浏览器的可以参考修改为 Raphael 的版本，这里不再赘述。</p>
<h2 id="参考">参考</h2><ol>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/SVG" target="_blank" rel="external">SVG</a></li>
<li><a href="http://baike.baidu.com/subview/85022/9539763.htm?fromtitle=%40%23Protect%40%23" target="_blank" rel="external">SVG （可缩放矢量图形）</a></li>
<li><a href="http://www.zhihu.com/question/19690014" target="_blank" rel="external">SVG 与 HTML5 的 canvas 各有什么优点，哪个更有前途？</a></li>
<li><a href="http://segmentfault.com/a/1190000000490137" target="_blank" rel="external">HTML5之图形绘制技术（Canvas Vs SVG）</a></li>
<li><a href="http://www.oxxostudio.tw/articles/201406/svg-04-path-1.html" target="_blank" rel="external">SVG 研究之路 (4) - Path 基礎篇</a></li>
<li><a href="http://www.zhangxinxu.com/wordpress/2014/01/snap-svg-study-demo-docs/" target="_blank" rel="external">Snap.svg-SVG实战学习必修课-实例与文档讲解</a></li>
<li><a href="http://xbingoz.com/320.html" target="_blank" rel="external">【MDN】SVG教程(5) 路径 [译]</a></li>
<li><a href="http://www.zhangxinxu.com/wordpress/2013/09/svg-fallbacks/" target="_blank" rel="external">一些SVG向下兼容优雅降级技术</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://7tt058.com1.z0.glb.clouddn.com/svg.png" alt="svg"></p>
<p>SVG 是可缩放矢量图形（Scalable Vector Graphics，SVG），是一种描述二位矢量图形的 XML 标记语言。</p>
<p>百科中对 SVG 的说明：</p>
<blockquote>
<ol>
<li>SVG 指可伸缩矢量图形 (Scalable Vector Graphics)</li>
<li>SVG 用来定义用于网络的基于矢量的图形</li>
<li>SVG 使用 XML 格式定义图形</li>
<li>SVG 图像在放大或改变尺寸的情况下其图形质量不会有所损失</li>
<li>SVG 是万维网联盟的标准</li>
<li>SVG 与诸如 DOM 和 XSL 之类的 W3C 标准是一个整体</li>
</ol>
</blockquote>
<p>SVG 和 Canvas 是 HTML5 中主要的 2D 图形相关技术。一方面，在 HTML5 发展的大环境下，SVG 有很好的机遇。另一方面，它的主要对手是 flash，同 flash 相比，它与很多标准（如 XSL 和 DOM 等）相兼容，而 flash 是非开源的私有技术。所以，如此看来，SVG 在未来的图形开发中必将占据重要的一席之地。</p>]]>
    
    </summary>
    
      <category term="SVG" scheme="http://reygreen1.github.io/tags/SVG/"/>
    
      <category term="SVG" scheme="http://reygreen1.github.io/categories/SVG/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[circle progress 环形进度条]]></title>
    <link href="http://reygreen1.github.io/2015/09/08/canvas-circle-progress/"/>
    <id>http://reygreen1.github.io/2015/09/08/canvas-circle-progress/</id>
    <published>2015-09-07T16:00:00.000Z</published>
    <updated>2015-09-08T12:19:34.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://7tt058.com1.z0.glb.clouddn.com/progress.png" alt="circle progress"></p>
<p>最近开发中有这样一个需求，需要设计出环形进度条的效果，而且要兼容低版本浏览器。</p>
<p>我们知道，传统方式下，除非使用图片，不然没办法做出这种圆环的动态效果。但是进度数据的范围相对而言比较广（整数值状态下为 0%~100% ，约 100 个独立状态），每个状态用图片来做显然是不现实的。</p>
<p>既然传统方式不行，那就必须考虑其他方式来解决问题。CSS3、Canvas 等都是可以参考的解决方案。使用这些技术有利有弊，依赖其他一些辅助库或框架，可以让解决方案变得更加完美。</p>
<p>我们分析下使用这些技术是如何解决环形进度条需求的。</p>
<a id="more"></a>
<h2 id="传统方式">传统方式</h2><p>传统方式一般采用背景图片来解决上面的需求。</p>
<h3 id="原理">原理</h3><p>具体做法是，将各个状态下的图片拼成一个 sprite ，定时更新 background-position 来显示各个状态下的图片，时间间隔掌握合适的话就形成了动画。这是最简单粗暴的做法。</p>
<h3 id="优势">优势</h3><ul>
<li>基本不用编写复杂的绘图代码，只要写好定时器部分的逻辑即可完成交互。</li>
<li>每个状态都可以用图来表示，展现复杂的进度效果很简单，只需要修改 PSD 即可。</li>
<li>整体来说，对开发人员的要求较低。</li>
</ul>
<h3 id="缺点">缺点</h3><ul>
<li>如前文所述，对状态点的数目很敏感。正常情况下的 100（0%~100%） 个状态需要相同数据的图片。当然也可以减少状态点的数目，但是这么做有可能会影响到后期状态切换时的渐进效果。</li>
<li>后期需要修改状态点展现时，需要重新制作 sprite 。使用工具可以解决这个问题。</li>
</ul>
<h2 id="CSS3">CSS3</h2><p>CSS3 本身提供很多强大的属性，可以通过使用 border-radius、transform 等属性来完成上面的需求。</p>
<h3 id="原理-1">原理</h3><p>先做一个环形的进度条，然后在它上面分别放置左右两个半圆（使用 clip 来显示一个圆的一半区域），最后定时旋转（使用 transform 中的 rotate 来实现）这两个半圆来显示出下面的进度条。连续执行后就形成了渐进的动画。</p>
<p>这里主要使用的 CSS 属性的相关用法可以参考下面的链接：</p>
<ul>
<li><a href="http://www.w3cplus.com/css3/border-radius" target="_blank" rel="external">border-radius</a></li>
<li><a href="http://www.w3cplus.com/css3/clip.html" target="_blank" rel="external">clip</a></li>
<li><a href="http://www.w3cplus.com/content/css3-transform" target="_blank" rel="external">transform</a></li>
</ul>
<h3 id="实例">实例</h3><iframe height="268" scrolling="no" src="//codepen.io/reygreen1/embed/pjJJqe/?height=268&amp;theme-id=18663&amp;default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/reygreen1/pen/pjJJqe/" target="_blank" rel="external">circleProgress</a> by reygreen1 (<a href="http://codepen.io/reygreen1" target="_blank" rel="external">@reygreen1</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.<br></iframe>

<h3 id="优势-1">优势</h3><ul>
<li>由于使用 CSS 属性设置进度条状态，修改状态就比较方便，只需要修改属性值即可。</li>
<li>已经有很多 CSS 效果的工具或者站点，类似效果也有很多 demo，可以直接拿来修改使用。</li>
</ul>
<h3 id="缺点-1">缺点</h3><ul>
<li>低版本浏览器的支持问题。使用的一些属性在低版本浏览器下不兼容，无法满足上文的第二条需求。有相关库或者脚本来解决 IE8 及更低版本浏览器对 CSS3 的支持问题（ <a href="http://www.zhangxinxu.com/wordpress/2010/04/%E8%AE%A9ie6ie7ie8%E6%B5%8F%E8%A7%88%E5%99%A8%E6%94%AF%E6%8C%81css3%E5%B1%9E%E6%80%A7/" target="_blank" rel="external">ie-css3.htc</a>、<a href="http://css3pie.com/" target="_blank" rel="external">CSS3 PIE</a>等）。</li>
<li>使用 CSS3 可以制作很酷炫的效果，但对开发人员的要求也较高。在效果制作中有比较复杂的编码过程，即使是使用已有的代码，也需要花费一定成本来了解实现原理。</li>
</ul>
<h2 id="Canvas">Canvas</h2><p>Canvas 的实现就是使用 canvas 相关 API 在画板上画圆，定时刷新画板即可实现动态效果。</p>
<h3 id="原理-2">原理</h3><p>使用 canvas 相关接口（ arc、fillStyle、fill等）在画板上画图，使用定时器定时刷新画板上的显示，达到渐进动画的效果。</p>
<p>canvas 的相关使用可以参考这个链接：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API" target="_blank" rel="external">Canvas</a>。</p>
<h3 id="实例-1">实例</h3><iframe height="268" scrolling="no" src="//codepen.io/reygreen1/embed/bVdpNy/?height=268&amp;theme-id=18663&amp;default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/reygreen1/pen/bVdpNy/" target="_blank" rel="external">drawCircleProgress</a> by reygreen1 (<a href="http://codepen.io/reygreen1" target="_blank" rel="external">@reygreen1</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.<br></iframe>

<h3 id="优势-2">优势</h3><ul>
<li>canvas 制作的动画效果非常丰富，API 的使用也非常方便。熟悉的开发人员可以很快开发出强大的效果。</li>
<li>更多的网站和 DEMO 供你参考选择。</li>
</ul>
<h3 id="缺点-2">缺点</h3><ul>
<li>低版本浏览器兼容性问题。不支持的浏览器无法看到任何 canvas 上展现的效果。可以使用 <a href="https://github.com/arv/ExplorerCanvas" target="_blank" rel="external">excanvas.js</a> 来解决兼容性问题。</li>
<li>要求开发人员对 canvas 开发有一定了解。</li>
</ul>
<h2 id="总结">总结</h2><p>上面主要分析了三种圆形进度条的实现方式，各有优劣。读者可以根据自己的情况选择合适的解决方案。</p>
<p>笔者选择的是 canvas 的方式，使用 excanvas.js（压缩后约 7.5K） 来解决低版本浏览器的兼容性问题。</p>
<p>excanvas.js 相关介绍：</p>
<blockquote>
<p>DESCRIPTION</p>
<p>Firefox, Safari and Opera 9 support the canvas tag to allow 2D command-based<br>drawing operations. ExplorerCanvas brings the same functionality to Internet<br>Explorer; web developers only need to include a single script tag in their<br>existing canvas webpages to enable this support.</p>
</blockquote>
<p>但在使用过程中还是遇到了一些坑，如：</p>
<ol>
<li>excanvas.js 会对 canvas 做处理，<em>处理后 canvas 元素中的文本内容会被清空</em>。所以，如果有相关需要后续处理的数据不能放到 canvas 里，而要作为它的一个属性值来保存。具体可以参考上文实例中的 <em>process</em> 属性的设置。</li>
<li>使用 canvas 中的 arc 方法，如果是顺时针方向，在起始位置一致时，IE 不会进行渲染。excanvas.js 源码是这么写的：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IE won't render arches drawn counter clockwise if xStart == xEnd.</span></span><br><span class="line"><span class="keyword">if</span> (xStart == xEnd &amp;&amp; !aClockwise) &#123;</span><br><span class="line">      xStart += <span class="number">0.125</span>; <span class="comment">// Offset xStart by 1/80 of a pixel. Use something</span></span><br><span class="line">                       <span class="comment">// that can be represented in binary</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即使它做了修正，在使用过程中还是可能出现问题，如果有类似场景需要特别注意。可以参考上文实例中关于进度为 100% 时做的修正代码。</p>
<p>总体来说，这个脚本还是非常给力的，而且它已经出现在了一些产品的生产环境中，所以读者可以放心使用。</p>
<h2 id="参考">参考</h2><ol>
<li><a href="http://www.w3cplus.com/css3/create-radial-progress-bar-with-jQuery-and-css3.html" target="_blank" rel="external">利用jQuery和CSS实现环形进度条</a></li>
<li><a href="http://caibaojian.com/canvas-circular.html" target="_blank" rel="external">canvas绘制旋转的圆环百分比进度条</a></li>
<li><a href="http://www.jb51.net/css/28584.html" target="_blank" rel="external">让IE6、IE7、IE8支持CSS3的脚本</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://7tt058.com1.z0.glb.clouddn.com/progress.png" alt="circle progress"></p>
<p>最近开发中有这样一个需求，需要设计出环形进度条的效果，而且要兼容低版本浏览器。</p>
<p>我们知道，传统方式下，除非使用图片，不然没办法做出这种圆环的动态效果。但是进度数据的范围相对而言比较广（整数值状态下为 0%~100% ，约 100 个独立状态），每个状态用图片来做显然是不现实的。</p>
<p>既然传统方式不行，那就必须考虑其他方式来解决问题。CSS3、Canvas 等都是可以参考的解决方案。使用这些技术有利有弊，依赖其他一些辅助库或框架，可以让解决方案变得更加完美。</p>
<p>我们分析下使用这些技术是如何解决环形进度条需求的。</p>]]>
    
    </summary>
    
      <category term="canvas" scheme="http://reygreen1.github.io/tags/canvas/"/>
    
      <category term="进度条" scheme="http://reygreen1.github.io/tags/%E8%BF%9B%E5%BA%A6%E6%9D%A1/"/>
    
      <category term="Canvas" scheme="http://reygreen1.github.io/categories/Canvas/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iPad4 换屏指南]]></title>
    <link href="http://reygreen1.github.io/2015/08/25/replacement-of-iPad-touch-screen/"/>
    <id>http://reygreen1.github.io/2015/08/25/replacement-of-iPad-touch-screen/</id>
    <published>2015-08-24T16:00:00.000Z</published>
    <updated>2015-08-25T09:22:22.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://7tt058.com1.z0.glb.clouddn.com/iPad4.jpg" alt="iPad4 换屏"></p>
<p>前段时间，给儿子用的 iPad4 屏幕被摔碎，已经无法正常使用，需要进行换屏。</p>
<p>目前的官方换屏价格非常昂贵，仔细算下来不如加点钱换个新的 iPad，所以首先放弃了官方换屏的想法。其次，其他非官方的换屏服务质量良莠不齐，而且价格差异也很大，选来选去总是不放心。考虑再三，我准备使用 360 同城帮的换屏服务，价格也算可以，而且服务有保证。但是很不幸的是，过去一直有的上门服务居然没有了，所以也放弃了。</p>
<p>另一方面总是看到网上的各种换屏教程，一直没有机会尝试。这次有这个机会可以实际操作一把，即使失败了也有很好的借口（反正是儿子摔坏的）来敷衍老婆。</p>
<p>就是因为上面这些杂七杂八的想法，才让我下定决心自己换屏。</p>
<a id="more"></a>
<p>网上搜索下就可以看到，换屏的过程真的不是很复杂（如果你动手换过）。自己换屏的话，一个触摸屏的成本也不高，这么算下来其实是挺划算的。当然，风险（可以控制）也肯定是有的，只是没有想象中那么大而已。</p>
<p>下面简单介绍下自己更换屏幕的过程：</p>
<h2 id="知识储备">知识储备</h2><p>首先，你需要大致了解换屏的整个过程，以及需要特别注意的操作细节。不然，一不小心损坏一个零件就可能导致你的设备产生无法修复的故障。</p>
<p>这里我主要参考了一下几个资源：</p>
<ol>
<li><a href="http://bbs.feng.com/read-htm-tid-6569827.html" target="_blank" rel="external">ipad4外屏碎，换屏成功简单过程</a></li>
<li><a href="http://v.youku.com/v_show/id_XNjgxODg4MzQw.html?firsttime=0&amp;from=y1.9-4" target="_blank" rel="external">视频: 国内最详细iPad4更换触摸屏教程</a></li>
</ol>
<p>第一个帖子的作者跟我经历相似，都是孩子把屏幕摔碎，然后记录了自己动手更换屏幕的整个过程。第二个视频非常赞，拆装过程讲解的非常细致，每个阶段的要点都进行了总结，强烈推荐提前先看一遍。但是要注意的是，这里作者拆的是屏幕没有破损的 iPad。这可能跟大家的实际情况不一致，在拆解触摸屏时需要比作者做更多清理碎玻璃的操作。</p>
<h2 id="准备工作">准备工作</h2><p>换屏前我们需要准备的资源及工具有：</p>
<h3 id="1-_需要换屏的_iPad4">1. 需要换屏的 iPad4</h3><p><img src="http://7tt058.com1.z0.glb.clouddn.com/换屏前.jpg" alt="换屏前"></p>
<h3 id="2-_原装触摸屏（可以去某宝淘到，价格不超过200RMB）">2. 原装触摸屏（可以去某宝淘到，价格不超过200RMB）</h3><p><img src="http://7tt058.com1.z0.glb.clouddn.com/原装触摸屏.jpg" alt="原装触摸屏"></p>
<h3 id="3-_换屏工具（翘刀、翘片、镊子、绝缘撬棒、螺丝刀等）">3. 换屏工具（翘刀、翘片、镊子、绝缘撬棒、螺丝刀等）</h3><p><img src="http://7tt058.com1.z0.glb.clouddn.com/准备工具.jpg" alt="准备工具"></p>
<h3 id="4-吹风机">4.吹风机</h3><p>家用的吹风机即可，主要用来吹热触摸屏下面的胶。</p>
<h2 id="拆除触摸屏">拆除触摸屏</h2><p>首先使用吹风机将 iPad 四周白边区域吹热，然后找到一个稍微容易下刀的位置将屏幕慢慢翘起。同时用翘片或者其他卡片塞入翘起的缝隙，防止屏幕再次粘住下面的边框。</p>
<p>要注意，边用吹风机加热，边翘起 iPad 边缘，不然有可能将屏幕翘裂。因为，屏幕有可能在崩裂的时候弹出小玻璃渣，蹦到身上或者地上都是非常难弄的。</p>
<blockquote>
<p>特别需要注意的地方：<em>HOME 键</em>左右的白色区域分别有<em>触摸屏排线</em>、<em>HOME键排线</em>和 <em>wifi 模块</em>。在处理这部分区域的时候要特别注意，不要弄断任何排线，不然你整个换屏操作就前功尽弃了。</p>
</blockquote>
<p>还有需要注意的是，有时候边缘的碎玻璃处理起来非常麻烦，需要有耐心一点点用刀片刮下来，同时尽量把碎玻璃清理干净，不然后面粘合新屏幕的时候非常麻烦。</p>
<p>经过上面的操作步骤，触摸屏就跟下面的设备分离了，小心将屏幕翻转过来（注意不要扯断<em>触摸屏的排线</em>和 <em>HOME 键排线</em>）。如下图所示：</p>
<p><img src="http://7tt058.com1.z0.glb.clouddn.com/卸下触摸屏.jpg" alt="卸下触摸屏"></p>
<h2 id="更换触摸屏">更换触摸屏</h2><p>现在我们需要将旧触摸屏的排线拆下来，同时更换新的触摸屏。</p>
<p>首先，需要将 <em>HOME 键的排线</em>从旧触摸屏上拆下来。上面有两个非常小的螺丝，用螺丝刀卸下即可。注意，螺丝要注意存放好，一会儿还需要使用的。</p>
<p>然后，我们需要拆下触摸屏的排线。因为触摸屏的排线在<em>显示屏</em>的下面，所以需要将<em>显示屏</em>先拆除。用螺丝刀卸下显示屏四周的四个螺丝（注意保存好）。轻轻翘起显示屏，注意不要扯断显示屏的排线。翻转显示屏，可以看到下面的排线。排线是有开关固定的，用<em>绝缘撬棒</em>（金属的会导电，<em>千万注意不能用金属工具</em>）轻翘开关即可卸下排线。同理，可以卸下最下面的触摸屏排线，这样就的触摸屏就被完整卸下来了。</p>
<p>最后，安装新的触摸屏。先安装触摸屏的排线，然后是显示屏的排线，最后安装 <em>HOME 键</em>的排线。</p>
<p>到这里，更换触摸屏的工作基本完成。先不急着固定显示屏，我们先来开机测试下触摸屏的效果。</p>
<p>如果测试触摸屏反应没有任何异常（包括 <em>HOME 键</em>的功能），继续进行下面的步骤。</p>
<h2 id="封装">封装</h2><p>这是整个过程最后一步操作，也是非常需要耐心的一步。</p>
<h3 id="1-_固定显示屏">1. 固定显示屏</h3><p>用刚才拆下来的螺丝固定好显示屏的四个角。注意，不要触碰到显示屏的屏幕，防止弄脏或者弄坏屏幕。</p>
<h3 id="2-_屏幕除尘">2. 屏幕除尘</h3><p>将显示屏和触摸屏的内侧清理干净，主要是除垢和除尘，也要注意碎玻璃渣。这一步非常重要，因为如果处理不善，后面粘合后屏幕内的脏东西是无法清理的。屏幕上始终清晰显示尘块，非常难受。</p>
<h3 id="3-_粘合触摸屏">3. 粘合触摸屏</h3><p>最后一步，撕下触摸屏四周的胶条，小心翼翼将触摸屏覆盖到显示屏上。检查位置合适后，按压触摸屏四周的白色区域，将触摸屏粘合牢固。</p>
<p>整个换屏的过程到这里就结束了，下面是最后的成果：</p>
<p><img src="http://7tt058.com1.z0.glb.clouddn.com/更换完毕.jpg" alt="更换完毕"></p>
<h2 id="总结">总结</h2><p>从<em>时间</em>上来考虑，整个换屏的过程花费了大概2个小时的时间，其中清理和拆卸的工作花了大概有1小时20分钟。</p>
<p>从<em>成本</em>上来考虑，基本的触摸屏花费了不到 200 RMB，同时还赠送了拆卸的工具，还有一张不错的屏幕贴膜。这么算下来真的是很划算。</p>
<p>从<em>技术难度</em>上来考虑，全部操作过程都可以通过相关教程来学习掌握，实际操作难度并不大。在关键的几个地方注意不要犯错就 OK，不然损失就大了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://7tt058.com1.z0.glb.clouddn.com/iPad4.jpg" alt="iPad4 换屏"></p>
<p>前段时间，给儿子用的 iPad4 屏幕被摔碎，已经无法正常使用，需要进行换屏。</p>
<p>目前的官方换屏价格非常昂贵，仔细算下来不如加点钱换个新的 iPad，所以首先放弃了官方换屏的想法。其次，其他非官方的换屏服务质量良莠不齐，而且价格差异也很大，选来选去总是不放心。考虑再三，我准备使用 360 同城帮的换屏服务，价格也算可以，而且服务有保证。但是很不幸的是，过去一直有的上门服务居然没有了，所以也放弃了。</p>
<p>另一方面总是看到网上的各种换屏教程，一直没有机会尝试。这次有这个机会可以实际操作一把，即使失败了也有很好的借口（反正是儿子摔坏的）来敷衍老婆。</p>
<p>就是因为上面这些杂七杂八的想法，才让我下定决心自己换屏。</p>]]>
    
    </summary>
    
      <category term="iPad4" scheme="http://reygreen1.github.io/tags/iPad4/"/>
    
      <category term="换屏" scheme="http://reygreen1.github.io/tags/%E6%8D%A2%E5%B1%8F/"/>
    
      <category term="生活" scheme="http://reygreen1.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[WebGL编程起步]]></title>
    <link href="http://reygreen1.github.io/2015/05/25/start-coding-in-WebGL/"/>
    <id>http://reygreen1.github.io/2015/05/25/start-coding-in-WebGL/</id>
    <published>2015-05-25T03:05:16.000Z</published>
    <updated>2015-05-25T09:55:09.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://7tt058.com1.z0.glb.clouddn.com/webgl.jpg" alt="WebGL编程"></p>
<p>上篇文章简单介绍了WebGL的一些相关概念、现状以及工作原理，没有涉及到具体编码，本文将使用WebGL的相关技术来实现一个简单的效果示例，从而让大家了解WebGL编程的基本流程和关键操作。最后，还介绍了一些WebGL的库和框架，恰当的使用这些第三方框架，可以大大提高我们的工作效率。</p>
<a id="more"></a>
<h3 id="开发流程">开发流程</h3><p>WebGL的开发过程主要包括以下几个步骤：</p>
<h4 id="1-准备容器">1.准备容器</h4><p>WebGL要在页面上执行相关的渲染，必须依赖一个特定的容器，在HTML5中，使用的是Canvas作为容器。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">body</span> <span class="attribute">onload</span>=<span class="value">"start()"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">canvas</span> <span class="attribute">id</span>=<span class="value">"glcanvas"</span> <span class="attribute">width</span>=<span class="value">"640"</span> <span class="attribute">height</span>=<span class="value">"480"</span>&gt;</span></span><br><span class="line">    Your browser doesn't appear to support the HTML5 canvas element.</span><br><span class="line">  <span class="tag">&lt;/<span class="title">canvas</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如上所示，我们在HTML中添加了一个canvas元素，并且设置了onload事件作为入口，后续的所有业务逻辑都会在start函数中进行处理。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//WebGL全局变量</span></span><br><span class="line"><span class="keyword">var</span> gl；</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">"glcanvas"</span>);  </span><br><span class="line">    <span class="comment">//初始化上下文</span></span><br><span class="line">    gl = initGL(canvas);        </span><br><span class="line">    <span class="comment">//初始化着色器</span></span><br><span class="line">    initShaders();  </span><br><span class="line">    <span class="comment">//生成/加载模型数据</span></span><br><span class="line">    initBuffers();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置擦除颜色为黑色，透明度不透明</span></span><br><span class="line">    gl.clearColor(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);  </span><br><span class="line">    <span class="comment">//开启“深度测试”，z-缓存      </span></span><br><span class="line">    gl.enable(gl.DEPTH_TEST); </span><br><span class="line">        </span><br><span class="line">    <span class="comment">//渲染</span></span><br><span class="line">    drawScene(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码可以看出，我们整个的过程主要包含了四个比较重要的阶段：<i>初始化上下文</i>、<i>初始化着色器</i>、<i>加载模型数据</i>和<i>渲染</i>。下面会对这几个过程做详细介绍。</p>
<h4 id="2-初始化上下文">2.初始化上下文</h4><p>initGL方法主要用来初始化WebGL的绘制环境：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initGL</span><span class="params">(canvas)</span> </span>&#123;  </span><br><span class="line">  	gl=<span class="literal">null</span>;      </span><br><span class="line">  	<span class="keyword">try</span> &#123;</span><br><span class="line">    		<span class="comment">//尝试创建标准上下文，如果失败，回退到试验性上下文</span></span><br><span class="line">    		gl = canvas.getContext(<span class="string">"webgl"</span>) || canvas.getContext(<span class="string">"experimental-webgl"</span>);</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">catch</span>(e) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//如果没有GL上下文，马上放弃</span></span><br><span class="line">  	<span class="keyword">if</span> (!gl) &#123;</span><br><span class="line">    		alert(<span class="string">"Unable to initialize WebGL. Your browser may not support it."</span>);</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，我们为了得到WebGL上下文，需要使用canvas的getContext方法，这里有两个参数值可以使用：<b>webgl</b>或者<b>experimental-webgl</b>。不同浏览器环境下使用的参数不一样，具体可参照<a href="http://caniuse.com/#search=webgl" target="_blank" rel="external">WebGL - 3D Canvas graphics</a>。</p>
<h4 id="3-初始化着色器">3.初始化着色器</h4><p>在3D场景的开发过程中会涉及到非常多的计算过程（颜色、位置等），为了提高效率，使用了硬件加速，这个时候GPU的强大计算能力得到了运用。但是，怎样告诉它正确执行相关计算逻辑呢？答案是着色器。着色器告诉相关计算单元做什么，而着色器语言（GLSL）来告诉它们怎么做。</p>
<p><a href="https://www.khronos.org/registry/gles/specs/2.0/GLSL_ES_Specification_1.0.17.pdf" target="_blank" rel="external">The OpenGL ES Shading Language</a></p>
<p>一般情况下，我们在HTML中定义着色器，然后在代码中获取并使用。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">id</span>=<span class="value">"shader-fs"</span> <span class="attribute">type</span>=<span class="value">"x-shader/x-fragment"</span>&gt;</span><span class="glsl"></span><br><span class="line">    <span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="keyword">float</span>;</span><br><span class="line">    <span class="keyword">varying</span> <span class="keyword">vec4</span> vColor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> main(<span class="keyword">void</span>) &#123;</span><br><span class="line">        <span class="built_in">gl_FragColor</span> = vColor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">id</span>=<span class="value">"shader-vs"</span> <span class="attribute">type</span>=<span class="value">"x-shader/x-vertex"</span>&gt;</span><span class="glsl"></span><br><span class="line">    <span class="keyword">attribute</span> <span class="keyword">vec3</span> aVertexPosition;</span><br><span class="line">    <span class="keyword">attribute</span> <span class="keyword">vec4</span> aVertexColor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uniform</span> <span class="keyword">mat4</span> uMVMatrix;</span><br><span class="line">    <span class="keyword">uniform</span> <span class="keyword">mat4</span> uPMatrix;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">varying</span> <span class="keyword">vec4</span> vColor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> main(<span class="keyword">void</span>) &#123;</span><br><span class="line">        <span class="built_in">gl_Position</span> = uPMatrix * uMVMatrix * <span class="keyword">vec4</span>(aVertexPosition, <span class="number">1.0</span>);</span><br><span class="line">        vColor = aVertexColor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上文的代码中定义了两个着色器：<b>片段着色器</b>和<b>顶点着色器</b>。</p>
<p>顶点着色器定义了模型中顶点的位置和颜色信息。</p>
<p>片段着色器通过差值的方法来处理WebGL中像素的相关数据，这里定义了像素上颜色的计算方法。</p>
<p>我们在initShaders方法中来查找使用着色器：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shaderProgram;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">initShaders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> fragmentShader = getShader(gl, <span class="string">"shader-fs"</span>);</span><br><span class="line">        <span class="keyword">var</span> vertexShader = getShader(gl, <span class="string">"shader-vs"</span>);</span><br><span class="line">        <span class="comment">//创建着色器</span></span><br><span class="line">        shaderProgram = gl.createProgram();</span><br><span class="line">        gl.attachShader(shaderProgram, vertexShader);</span><br><span class="line">        gl.attachShader(shaderProgram, fragmentShader);</span><br><span class="line">        <span class="comment">//链接着色器程序</span></span><br><span class="line">        gl.linkProgram(shaderProgram);</span><br><span class="line">        <span class="comment">//检查着色器是否成功连接</span></span><br><span class="line">        <span class="keyword">if</span> (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) &#123;</span><br><span class="line">            alert(<span class="string">"Could not initialise shaders"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//连接成功后激活渲染器程序</span></span><br><span class="line">        gl.useProgram(shaderProgram);</span><br><span class="line"></span><br><span class="line">        shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, <span class="string">"aVertexPosition"</span>);</span><br><span class="line">        <span class="comment">//启用顶点缓冲区数组</span></span><br><span class="line">        gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);</span><br><span class="line"></span><br><span class="line">        shaderProgram.vertexColorAttribute = gl.getAttribLocation(shaderProgram, <span class="string">"aVertexColor"</span>);</span><br><span class="line">        gl.enableVertexAttribArray(shaderProgram.vertexColorAttribute);</span><br><span class="line"></span><br><span class="line">        shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, <span class="string">"uPMatrix"</span>);</span><br><span class="line">        shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, <span class="string">"uMVMatrix"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>上述代码加载了模型数据，并且通过一系列的绑定操作和相关设置，告诉GPU如何去处理相关的渲染过程。</p>
<p>这里使用了一个工具函数getShader，它的作用是从DOM中获取定义的相关着色器程序，并返回编译好的渲染器程序：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getShader</span><span class="params">(gl, id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> shaderScript, theSource, currentChild, shader;</span><br><span class="line">    </span><br><span class="line">    shaderScript = <span class="built_in">document</span>.getElementById(id);    </span><br><span class="line">    <span class="keyword">if</span> (!shaderScript) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取着色器的文本内容保存到theSource</span></span><br><span class="line">    theSource = <span class="string">""</span>;</span><br><span class="line">    currentChild = shaderScript.firstChild;    </span><br><span class="line">    <span class="keyword">while</span>(currentChild) &#123;</span><br><span class="line">        <span class="keyword">if</span> (currentChild.nodeType == currentChild.TEXT_NODE) &#123;</span><br><span class="line">            theSource += currentChild.textContent;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        currentChild = currentChild.nextSibling;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建顶点着色器或片段着色器</span></span><br><span class="line">    <span class="keyword">if</span> (shaderScript.type == <span class="string">"x-shader/x-fragment"</span>) &#123;</span><br><span class="line">      shader = gl.createShader(gl.FRAGMENT_SHADER);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shaderScript.type == <span class="string">"x-shader/x-vertex"</span>) &#123;</span><br><span class="line">      shader = gl.createShader(gl.VERTEX_SHADER);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">//非法类型返回null</span></span><br><span class="line">     <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   gl.shaderSource(shader, theSource);</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//编译着色器代码</span></span><br><span class="line">   gl.compileShader(shader);  </span><br><span class="line">    </span><br><span class="line">   <span class="comment">//检查是否编译成功</span></span><br><span class="line">   <span class="keyword">if</span> (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) &#123;  </span><br><span class="line">      alert(<span class="string">"An error occurred compiling the shaders: "</span> + gl.getShaderInfoLog(shader));  </span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//成功后返回编译好的着色器</span></span><br><span class="line">   <span class="keyword">return</span> shader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-生成/加载模型数据">4.生成/加载模型数据</h4><p>下面的initBuffers函数来将模型数据加载到缓冲器中，这样将顶点位置和颜色数据在上下文中准备就绪，随后才可以进行下一步的渲染操作。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> triangleVertexPositionBuffer;</span><br><span class="line">    <span class="keyword">var</span> triangleVertexColorBuffer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">initBuffers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        triangleVertexPositionBuffer = gl.createBuffer();</span><br><span class="line">        gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexPositionBuffer);</span><br><span class="line">        <span class="keyword">var</span> vertices = [</span><br><span class="line">             <span class="number">0.0</span>,  <span class="number">1.0</span>,  <span class="number">0.0</span>,</span><br><span class="line">            -<span class="number">1.0</span>, -<span class="number">1.0</span>,  <span class="number">0.0</span>,</span><br><span class="line">             <span class="number">1.0</span>, -<span class="number">1.0</span>,  <span class="number">0.0</span></span><br><span class="line">        ];</span><br><span class="line">        gl.bufferData(gl.ARRAY_BUFFER, <span class="keyword">new</span> <span class="built_in">Float32Array</span>(vertices), gl.STATIC_DRAW);</span><br><span class="line">        triangleVertexPositionBuffer.itemSize = <span class="number">3</span>;</span><br><span class="line">        triangleVertexPositionBuffer.numItems = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        triangleVertexColorBuffer = gl.createBuffer();</span><br><span class="line">        gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexColorBuffer);</span><br><span class="line">        <span class="keyword">var</span> colors = [</span><br><span class="line">            <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>,</span><br><span class="line">            <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>,</span><br><span class="line">            <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span></span><br><span class="line">        ];</span><br><span class="line">        gl.bufferData(gl.ARRAY_BUFFER, <span class="keyword">new</span> <span class="built_in">Float32Array</span>(colors), gl.STATIC_DRAW);</span><br><span class="line">        triangleVertexColorBuffer.itemSize = <span class="number">4</span>;</span><br><span class="line">        triangleVertexColorBuffer.numItems = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-渲染">5.渲染</h4><p>经过上一步的模型数据准备后，就可以直接通过WegGL来进行渲染了。下面的drawScene方法，对3D模型进行了一些基本设置，然后根据缓冲区中的相关数据，来绘制出相应的效果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawScene</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        gl.viewport(<span class="number">0</span>, <span class="number">0</span>, gl.viewportWidth, gl.viewportHeight);</span><br><span class="line">        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">        pMatrix = okMat4Proj(<span class="number">45.0</span>, gl.viewportWidth / gl.viewportHeight, <span class="number">0.1</span>, <span class="number">100.0</span>);</span><br><span class="line">        mvMatrix = okMat4Trans(-<span class="number">1.5</span>, <span class="number">0.0</span>, -<span class="number">7.0</span>);</span><br><span class="line"></span><br><span class="line">        gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexPositionBuffer);</span><br><span class="line">        gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, triangleVertexPositionBuffer.itemSize,</span><br><span class="line">  gl.FLOAT, <span class="literal">false</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexColorBuffer);</span><br><span class="line">        gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, triangleVertexColorBuffer.itemSize, </span><br><span class="line">gl.FLOAT, <span class="literal">false</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        setMatrixUniforms();</span><br><span class="line">        gl.drawArrays(gl.TRIANGLES, <span class="number">0</span>, triangleVertexPositionBuffer.numItems);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>至此，一个完整的WebGL程序基本开发完毕了，通过上面的过程我们发现，使用原生的WebGL来进行特殊场景的开发简直就是一种折磨。我们需要了解各种实现细节和专业知识，这对于非专业的开发人员是一种极大的挑战。所以，自然而然就有大量的类库和框架出现，来简化我们的开发过程，提高我们的工作效率。</p>
<p><a href="https://jsfiddle.net/p924bve3/" target="_blank" rel="external">点击这里可以看到用three.js来实现的上文效果</a></p>
<h3 id="WebGL库和框架">WebGL库和框架</h3><p>下面简单介绍一些WebGL的类库或者框架：</p>
<p><a href="http://threejs.org/" target="_blank" rel="external">three.js</a>，这是一个低复杂、轻量级的开源框架，也是目前应用最广泛的3D框架，模型文件支持多种格式，渲染器的选择也非常灵活，方便使用者快速开发各种效果。</p>
<p><a href="http://www.senchalabs.org/philogl/" target="_blank" rel="external">PhiloGL</a>，这也是一个开源框架，注重性能，拥有非常强大的接口，比较适合数据可视化和游戏开发。</p>
<p><a href="http://www.babylonjs.com/" target="_blank" rel="external">Babylon.js</a>，这是一款非常适合作为游戏引擎的开源框架，让WebGL的使用更加简单、强大，非常适合游戏开发。</p>
<p><a href="http://scenejs.org/" target="_blank" rel="external">SceneJS</a>，这一开源框架的特点在于，对于高精度的细节控制非常好，适合的领域有工程学、医学建模等。</p>
<p><a href="http://www.ambiera.com/copperlicht/" target="_blank" rel="external">CopperLicht</a>，这是一个非常出色的3D引擎，并且带有编辑器，唯一的缺点是，他不是开源的，如果商用需要购买。</p>
<h3 id="参考">参考</h3><ol>
<li><a href="http://www.uml.org.cn/html/201208151.asp" target="_blank" rel="external">突袭HTML5之WebGL 3D概述</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/WebGL/Adding_2D_content_to_a_WebGL_context" target="_blank" rel="external">Adding 2D content to a WebGL context</a></li>
<li><a href="https://www.khronos.org/registry/gles/specs/2.0/GLSL_ES_Specification_1.0.17.pdf" target="_blank" rel="external">The OpenGL® ES Shading Language</a></li>
<li><a href="http://www.csdn.net/article/a/2013-12-18/15817486" target="_blank" rel="external">WebGL 入门 – WebGL框架</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://7tt058.com1.z0.glb.clouddn.com/webgl.jpg" alt="WebGL编程"></p>
<p>上篇文章简单介绍了WebGL的一些相关概念、现状以及工作原理，没有涉及到具体编码，本文将使用WebGL的相关技术来实现一个简单的效果示例，从而让大家了解WebGL编程的基本流程和关键操作。最后，还介绍了一些WebGL的库和框架，恰当的使用这些第三方框架，可以大大提高我们的工作效率。</p>]]>
    
    </summary>
    
      <category term="WebGL" scheme="http://reygreen1.github.io/tags/WebGL/"/>
    
      <category term="three.js" scheme="http://reygreen1.github.io/tags/three-js/"/>
    
      <category term="WebGL" scheme="http://reygreen1.github.io/categories/WebGL/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[初识WebGL]]></title>
    <link href="http://reygreen1.github.io/2015/05/20/about-webGl/"/>
    <id>http://reygreen1.github.io/2015/05/20/about-webGl/</id>
    <published>2015-05-20T07:52:24.000Z</published>
    <updated>2015-05-20T10:40:26.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://7tt058.com1.z0.glb.clouddn.com/webgl-html5.png" alt="HTML5和WebGL"></p>
<h3 id="先来看看WebGL的官方介绍：">先来看看WebGL的官方介绍：</h3><blockquote>
<p>WebGL - OpenGL ES 2.0 for the Web</p>
</blockquote>
<p>WebGL — Web上的OpenGL ES 2.0</p>
<blockquote>
<p>WebGL is a cross-platform, royalty-free web standard for a low-level 3D graphics API based on OpenGL ES 2.0, exposed through the HTML5 Canvas element as Document Object Model interfaces. Developers familiar with OpenGL ES 2.0 will recognize WebGL as a Shader-based API using GLSL, with constructs that are semantically similar to those of the underlying OpenGL ES 2.0 API. It stays very close to the OpenGL ES 2.0 specification, with some concessions made for what developers expect out of memory-managed languages such as JavaScript.</p>
</blockquote>
<p>WebGL是一种跨平台并且可以自由使用的3D图形API，它基于OpenGL ES 2.0，并且通过HTML5 Canvas来将自己暴露为DOM接口。因为WebGL在语义上同OpenGL ES 2.0的基础接口非常类似，所以熟悉OpenGL ES 2.0的开发者会把WebGL当做使用GLSL（OpenGL Shading Language，OpenGL着色语言）的一套API。它同OpenGL ES 2.0的标准非常类似，只是在某些地方为顺应开发者需求做了妥协。</p>
<blockquote>
<p>WebGL brings plugin-free 3D to the web, implemented right into the browser. Major browser vendors Apple (Safari), Google (Chrome), Mozilla (Firefox), and Opera (Opera) are members of the WebGL Working Group.</p>
</blockquote>
<p>WebGL为web带来了无插件化的3D技术，这种实现非常适合浏览器。目前，主要的浏览器生产商Apple (Safari), Google (Chrome), Mozilla (Firefox), and Opera (Opera)都成为了WebGL工作组的成员。</p>
<p>补充：2014年微软也加入了WebGL工作组(IE11已经支持WebGL)。</p>
<a id="more"></a>
<h2 id="WebGL是什么？">WebGL是什么？</h2><p>WebGL是一种3D绘图标准，它提供了一套JS版本的API接口，通过调用这些接口可以直接使用OpenGL ES 2.0的功能，从而实现强大的3D绘图效果。</p>
<p>WebGL在HTML5中使用Canvas作为宿主，能够在渲染的过程中使用硬件加速，这让3D模型的展示更加流畅，在特定的业务场景中具有非常明显的优势。</p>
<p>最后需要重点提醒的是，WebGL在浏览器中展示3D效果不需要额外安装任何插件。对于支持WebGL的浏览器来说，可以直接用JavaScript来实现3D效果。</p>
<p>目前对WebGL提供支持的浏览器有<a href="https://developer.mozilla.org/en-US/docs/Firefox_4_for_developers" target="_blank" rel="external">Firefox 4</a>+ 、<a href="http://www.google.com/chrome/" target="_blank" rel="external">Google Chrome</a> 9+ 、<a href="http://www.opera.com/" target="_blank" rel="external">Opera</a> 12+和<a href="http://www.apple.com.cn/safari/" target="_blank" rel="external">Safari</a> 5.1+。</p>
<h2 id="3D图形API">3D图形API</h2><p>我们平时了解较多的3D图形API主要有OpenGL、DirectX。</p>
<p>OpenGL（Open Graphics Library，开放图形库）使用非常广泛，因为其跨平台性，在各种操作系统下都有很多应用场景，开发游戏、工业建模、嵌入式设备等。</p>
<p>DirectX是微软创建的一系列为多媒体以及游戏开发服务的应用程序接口，主要应用场景是在windows系统下进行游戏开发，基本在这个领域下无任何对手。</p>
<p>OpenGL ES可以看做是OpenGL的一个子集，专注于嵌入式设备。OpenGL ES 2.0是其中一个主要版本，它采用了可编程的渲染管线，渲染能力有了非常大的提高，它要求设备必须有相应的GPU硬件支持，不支持软件模拟实现。</p>
<h2 id="WebGL、OpenGL与OpenGL_ES_2-0">WebGL、OpenGL与OpenGL ES 2.0</h2><p>WebGL、OpenGL和OpenGL ES 2.0的相互关系可以参考下图：</p>
<p><img src="http://7tt058.com1.z0.glb.clouddn.com/OpenGL-related-Ecosystem.jpg" alt="OpenGL相关生态体系"></p>
<p>从图中可以看出，OpenGL ES是OpenGL的子集，WebGL同时在OpenGL和OpenGL ES 2.0上基础上构建出了JavaScript API，依托于HTML5，在浏览器上实现了无插件依赖的3D技术。</p>
<p>WebGL是JavaScript的API接口，对于web开发人员来说更加友好，使用起来更容易上手。</p>
<p>OpenGL相对来说，门槛比较高，涉及的专业知识很多，如着色语言、投影变换、光照、纹理等，需要花费比较多的时间去学习整理。</p>
<h2 id="OpenGL_ES_3-0">OpenGL ES 3.0</h2><p>Khronos Group在SIGGRAPH 2012专业图形大会上宣布了新一代移动3D图形标准规范“OpenGL ES 3.0”。</p>
<p>WebGL是基于OpenGL ES 2.0的，到目前为止还没有考虑过3.0，虽然3.0提出了很多新的功能。</p>
<p>Android对于OpenGL ES 3.0的相关说明：</p>
<blockquote>
<p>OpenGL ES 3.0 - This API specification is supported by Android 4.3 (API level 18) and higher.</p>
</blockquote>
<p>同时，它还声明，设备必须需要设备生产商来实现相关图形管线，也就是说如果设备生产商不实现相关支持，即使是4.3或者更高版本的系统也无法运行OpenGL ES 3.0的API。</p>
<h2 id="参考">参考</h2><ol>
<li><a href="http://cn.khronos.org/webgl" target="_blank" rel="external">WebGL - OpenGL ES 2.0 for the Web</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/WebGL" target="_blank" rel="external">WebGL</a></li>
<li><a href="http://www.oschina.net/p/webgl" target="_blank" rel="external">Web的3D绘图标准 WebGL</a></li>
<li><a href="http://news.mydrivers.com/1/236/236922.htm" target="_blank" rel="external">移动3D图形新起点：OpenGL ES 3.0规范发布</a></li>
<li><a href="http://developer.android.com/guide/topics/graphics/opengl.html" target="_blank" rel="external">OpenGL ES</a></li>
<li><a href="http://www.zhihu.com/question/24813635" target="_blank" rel="external">微软为何要在 2014 年加入 WebGL 小组？</a></li>
<li><a href="http://www.zhihu.com/question/19993499" target="_blank" rel="external">WebGL 是否需要以 OpenGL 为学习基础？</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://7tt058.com1.z0.glb.clouddn.com/webgl-html5.png" alt="HTML5和WebGL"></p>
<h3 id="先来看看WebGL的官方介绍：">先来看看WebGL的官方介绍：</h3><blockquote>
<p>WebGL - OpenGL ES 2.0 for the Web</p>
</blockquote>
<p>WebGL — Web上的OpenGL ES 2.0</p>
<blockquote>
<p>WebGL is a cross-platform, royalty-free web standard for a low-level 3D graphics API based on OpenGL ES 2.0, exposed through the HTML5 Canvas element as Document Object Model interfaces. Developers familiar with OpenGL ES 2.0 will recognize WebGL as a Shader-based API using GLSL, with constructs that are semantically similar to those of the underlying OpenGL ES 2.0 API. It stays very close to the OpenGL ES 2.0 specification, with some concessions made for what developers expect out of memory-managed languages such as JavaScript.</p>
</blockquote>
<p>WebGL是一种跨平台并且可以自由使用的3D图形API，它基于OpenGL ES 2.0，并且通过HTML5 Canvas来将自己暴露为DOM接口。因为WebGL在语义上同OpenGL ES 2.0的基础接口非常类似，所以熟悉OpenGL ES 2.0的开发者会把WebGL当做使用GLSL（OpenGL Shading Language，OpenGL着色语言）的一套API。它同OpenGL ES 2.0的标准非常类似，只是在某些地方为顺应开发者需求做了妥协。</p>
<blockquote>
<p>WebGL brings plugin-free 3D to the web, implemented right into the browser. Major browser vendors Apple (Safari), Google (Chrome), Mozilla (Firefox), and Opera (Opera) are members of the WebGL Working Group.</p>
</blockquote>
<p>WebGL为web带来了无插件化的3D技术，这种实现非常适合浏览器。目前，主要的浏览器生产商Apple (Safari), Google (Chrome), Mozilla (Firefox), and Opera (Opera)都成为了WebGL工作组的成员。</p>
<p>补充：2014年微软也加入了WebGL工作组(IE11已经支持WebGL)。</p>]]>
    
    </summary>
    
      <category term="WebGL" scheme="http://reygreen1.github.io/tags/WebGL/"/>
    
      <category term="JavaScript" scheme="http://reygreen1.github.io/categories/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[初玩Visual Studio Code]]></title>
    <link href="http://reygreen1.github.io/2015/04/30/about-vscode/"/>
    <id>http://reygreen1.github.io/2015/04/30/about-vscode/</id>
    <published>2015-04-30T08:52:15.000Z</published>
    <updated>2015-04-30T11:13:32.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://7tt058.com1.z0.glb.clouddn.com/vscode.png" alt="Visual Studio Code"></p>
<p>微软在今年的Build大会上发布了一款新型的代码编辑器Visual Studio Code，它一出现就吸引了大多数开发者的关注，尤其是前端开发人员。</p>
<blockquote>
<p>Build and debug modern web and cloud applications. Code is free and available on your favorite platform - Linux, Mac OSX, and Windows.</p>
</blockquote>
<p>如官网介绍，Code的特点是免费、跨平台，它专注于代码开发过程，提供调试工具，定位轻量级的代码编辑器，将竞争的矛头直接指向<a href="http://www.sublimetext.com/" target="_blank" rel="external">Sublime Text</a>、<a href="https://atom.io/" target="_blank" rel="external">Atom</a>。</p>
<p>笔者今天使用了一天Code的预览版，下面来简单介绍下这款工具的一些优缺点。</p>
<a id="more"></a>
<h3 id="定位">定位</h3><p>首先必须明确说明，Code仅仅是一个轻量级的代码编辑器，跟我们平时使用的Sublime、Atom类似，绝不是完整的IDE（集成开发环境），区别于Visual Studio等。</p>
<h3 id="界面">界面</h3><p>不得不说这真是一款颜值颇高的编辑器，启动后的给人一种非常舒服的感觉。</p>
<p><img src="http://7tt058.com1.z0.glb.clouddn.com/vscode-layout.png" alt="Code界面"></p>
<p>左侧除了有在Sublime中掺假的目录结构，还多了一个侧边栏的导航，功能包含了搜索、git和debug的功能。在不同的导航界面下，目录面板会有不同的功能设置。</p>
<p>还有一个需要注意的是，最右侧只剩下了一个导航条来显示当前视图在整个文件中的位置，而Sublime中使用的是文件内容缩略图。在文件内容较多的时候，滚动条无法提供一种“即视感”，所以我还是比较偏爱Sublime的这种设置。</p>
<h3 id="文件和文件夹操作">文件和文件夹操作</h3><p>首先，Code里打开一个项目就会新建一个视图窗口，而Sublime里可以同时在FOLDERS下同时打开多个项目，区别还是不小。不过貌似，这对专注单一项目的同学还好，要是对像我这种需要在不同项目里跳来跳去的人来说，还是Sublime的更加合适。</p>
<p>当鼠标放在项目根目录上时，会出现四个操作按钮，如下图所示：</p>
<p><img src="http://7tt058.com1.z0.glb.clouddn.com/file-opertion.png" alt=""></p>
<p>可以新建文件、文件夹和执行目录折叠的操作等，同时，右键新建操作更加接近真实的创建场景，如果你使用过Sublime的相关新建操作，就会发现Code的方式还是更容易接受。</p>
<p>另外，当前编辑窗口的右上角多了一个Split Editor的按钮，用来将当前窗口快速分割为左右两个，类似“分身”。</p>
<p> <img src="http://7tt058.com1.z0.glb.clouddn.com/file-splite.png" alt="窗口分身"></p>
<p>当然，Sublime也可以完成相同的功能，而且还可以上下分割，但是需要快捷键操作或者选择菜单，Code这里做了按钮，简单直接。</p>
<p>另一个槽点，既然支持多行文件编辑，但是居然不对多行选择进行支持！在Sublime里很方便的一条命令，居然在Code里玩不起来了，好伤心。</p>
<h3 id="智能提示">智能提示</h3><p>Sublime的智能提示是针对当前文件上下文的，试试Code的提示，简直要逆天了。</p>
<p><img src="http://7tt058.com1.z0.glb.clouddn.com/code-suggest.png" alt="智能提示"></p>
<p>HTML、JS、Angular的补全，个人感觉非常强大。如果要实现上图node相关的提示，则需要在文件开头添加：</p>
<blockquote>
<p>/// &lt;reference path=”typings/node/node.d.ts”</p>
</blockquote>
<h3 id="代码高亮">代码高亮</h3><p>目前Code的代码高亮功能完全不能跟Sublime相比，总是一种很单调的感觉。</p>
<p>但是，这个问题解决起来应该不会很难，只要Code在后续版本中支持插件扩展，万能的开发者肯定马上就可以让Code的Theme（目前只有dark和light两种风格）丰富起来。</p>
<h3 id="代码调试">代码调试</h3><p>debug的选项让人眼前一亮，最近又正好在写node模块，如果能在Code里debug代码真是非常方便。</p>
<p>但是，要想使用调试功能，必须先安装<a href="http://www.mono-project.com/download/" target="_blank" rel="external">Mono</a>，不然连node的调试都进行不了。更悲催的是，VSCode的安装包有65M左右，但是Mono的安装文件居然要200多M，安装完后占据600多M空间。</p>
<p><img src="http://7tt058.com1.z0.glb.clouddn.com/require-mono.png" alt="需要先安装Mono"></p>
<p>完成安装后，配置好加载项的相关配置，调试界面还是非常让人惊艳的：</p>
<p><img src="http://7tt058.com1.z0.glb.clouddn.com/code-debug.png" alt="Code调试node代码"></p>
<h3 id="性能">性能</h3><p>据说在打开大容量文件的速度上要比Sublime快不少，但我没有实际测试过。官网也有特别宣传编辑器的性能，所以有兴趣的同学可以私下测试对比下。</p>
<h3 id="插件支持">插件支持</h3><p>目前预览版不支持插件化，但我认为这只是一时状况而已，微软不可能会忽略Sublime的成功之道。相信在正式版中会有比较完美的支持。</p>
<hr>
<h3 id="总结">总结</h3><p>从上面的对比分析可以看出，Code本身有自己的亮点，但是目前并不完善（当然这只是预览版而已）。相信Code的开发者也一定注意到了上文提到的几个问题，期待在正式版中有所改进。但就目前的情况而言，Code无法撼动Sublime的地位，所以日常开发中，我还是会有选择的使用Code和Sublime。</p>
<hr>
<h3 id="参考">参考</h3><ol>
<li><a href="https://code.visualstudio.com/" target="_blank" rel="external">Visual Studio Code官网</a></li>
<li><a href="http://www.zhihu.com/question/29984607" target="_blank" rel="external">如何评价 Visual Studio Code？</a></li>
<li><a href="https://code.visualstudio.com/Download" target="_blank" rel="external">Code相关下载</a></li>
<li><a href="http://www.mono-project.com/download/" target="_blank" rel="external">Mono下载</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://7tt058.com1.z0.glb.clouddn.com/vscode.png" alt="Visual Studio Code"></p>
<p>微软在今年的Build大会上发布了一款新型的代码编辑器Visual Studio Code，它一出现就吸引了大多数开发者的关注，尤其是前端开发人员。</p>
<blockquote>
<p>Build and debug modern web and cloud applications. Code is free and available on your favorite platform - Linux, Mac OSX, and Windows.</p>
</blockquote>
<p>如官网介绍，Code的特点是免费、跨平台，它专注于代码开发过程，提供调试工具，定位轻量级的代码编辑器，将竞争的矛头直接指向<a href="http://www.sublimetext.com/">Sublime Text</a>、<a href="https://atom.io/">Atom</a>。</p>
<p>笔者今天使用了一天Code的预览版，下面来简单介绍下这款工具的一些优缺点。</p>]]>
    
    </summary>
    
      <category term="Visual Studio Code" scheme="http://reygreen1.github.io/tags/Visual-Studio-Code/"/>
    
      <category term="工具" scheme="http://reygreen1.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="工具" scheme="http://reygreen1.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[来，我们谈谈React Native]]></title>
    <link href="http://reygreen1.github.io/2015/04/12/about-react-native/"/>
    <id>http://reygreen1.github.io/2015/04/12/about-react-native/</id>
    <published>2015-04-11T16:00:00.000Z</published>
    <updated>2015-04-15T12:26:17.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://7tt058.com1.z0.glb.clouddn.com/reactnative.png" alt="React Native"></p>
<p>Facebook在今年的React.js Conf 2015上推出了React Native，而这已经成为目前最热门的讨论话题。</p>
<p>我们知道，传统的原生开发是需要一定门槛的，要转行为原生开发其实是比较困难的。这就导致了市场需求大，而相关开发人员不能满足的问题。相比较而言，web开发的入门就比较容易，相关的开发者也就比较多。如果能让一部分web开发者直接开发原生应用，这将是多么美好的一件事情啊，而这也是不少框架出现的直接原因。</p>
<p>如果你本身是就是各个平台原生应用的开发者，那么React Native貌似不会给你带来更大的兴趣。但是，作为使用javascript的web开发人员，它的出现无疑是影响巨大的。React Native让web开发人员通过习惯的开发方式(使用React)来开发原生应用成为了可能，更重要的是它提出了一种新的开发理念，而这也是它目前火爆的主要原因。</p>
<p>既然是React Native，那么它必然与Native有着或多或少的关系。没错，React是React Native的强有力支撑，在React Native的实现中占有非常重要的作用，但是这基本属于另一个话题，本文不会着重介绍React、Flux等相关概念。</p>
<a id="more"></a>
<h2 id="What’s_React_Native?">What’s React Native?</h2><blockquote>
<p>What we really want is the user experience of the native mobile platforms, combined with the developer experience we have when building with React on the web.</p>
</blockquote>
<p>从上面的这段介绍，我们可以看出，React Native的目的就是使开发人员可以通过React来开发原生应用。这说明使用React Native也是需要有一定学习成本的，不是直接使用传统的javascript就可以开发的，你需要先学会使用React。</p>
<blockquote>
<p>Learn once, write anywhere.</p>
</blockquote>
<p>React Native并不是像Java那样可以“write once, run anywhere.”。这是因为我们必须考虑不同原生平台上用户体验的差异性，过分要求应用在不同平台上的一致性其实是不合适的。所以，React Native的理念是，可以针对不同平台来写React代码，从而开发出合适的原生应用。</p>
<p>简而言之，React Native是这样的一个工具，它使用React作为用户界面构建的工具，并在此基础上重新包装了一个渲染引擎(不同平台可能不一致)，可以将Virtual DOM生成不同平台下的UI，并创建了一系列的bridge来让js同native code进行通信。这样，就可以通过编写React代码来生成Native应用了。</p>
<h3 id="绝对不是Hybrid_app">绝对不是Hybrid app</h3><p>其实，使用hybrid的方式来开发app的框架很早就出现了，但是React Native绝对不是这样的，它生成的app里面没有webview，使用的全是原生的UI。</p>
<h2 id="React_Native的运行机制">React Native的运行机制</h2><p>Facebook在React Native中使用了自己的开源工具<a href="https://facebook.github.io/react/docs/jsx-in-depth.html" target="_blank" rel="external">JSX</a>、<a href="https://github.com/facebook/css-layout" target="_blank" rel="external">css-layout</a>。</p>
<p>eact Native运行机制类似于一个浏览器引擎的渲染过程，它根据以下步骤来运行(以iOS平台为例)：</p>
<ol>
<li>加载。native代码加载相关React文件，使用javascriptCore.framework构建OCbridge，这里将核心组件的方法注入到了js里，以供native和js进行通信。</li>
<li>解析。解析的过程主要是把对应的解析结果映射到native上，类似于浏览器中DOM结构的解析过程。</li>
<li>渲染。使用css-layout解析相关的css规则，从而确定各个结点上的属性值。</li>
<li>绘制。最后将Native UI在视图上绘制出来。</li>
</ol>
<p>至于React Native内部的通信机制，已经有两篇文章介绍的比较详细，可以参考：</p>
<ol>
<li><a href="http://blog.cnbang.net/tech/2698/" target="_blank" rel="external">React Native通信机制详解</a></li>
<li><a href="http://www.hotobear.com/?p=1015" target="_blank" rel="external">React Native 初探（iOS）</a></li>
</ol>
<h2 id="React_Native的优势">React Native的优势</h2><h3 id="同webapp相比，native控件拥有更好的用户体验">同webapp相比，native控件拥有更好的用户体验</h3><p>在webapp中，毫无疑问，不管是如何模拟出来的原生效果，都没有native本身的效果更加细腻合适。在流畅性方面，native也是具有得天独厚的优势。其他还有手势识别、线程模型等，这些都是webapp所无法超越的。而对于Hybrid app，native应用可以完爆其交互和性能问题。</p>
<h3 id="同native相比，React符合web开发的习惯">同native相比，React符合web开发的习惯</h3><p>虽然React的使用也需要一些前期的成本，但是同学习native开发相比，对web开发者来说还是方便不少。同时，React Native中的js是可以运行在桌面chrome中的，通过websocket连接Native代码和chrome可以让调试变得非常方便。在React Native提供的示例中，我们可以很方便的通过CMD+R直接看到代码更新后的效果。</p>
<h2 id="目前还存在的问题">目前还存在的问题</h2><ol>
<li>平台一致的问题。目前React Native能支持Web和iOS，对于Android的支持需要稍后发布，不能保证各个平台同步改造。</li>
<li>使用成本的问题。需要学习React相关知识，需要进行概念转换。</li>
<li>依赖原生组件暴露出来的组件和方法。只能在已暴露的接口上做业务开发，限制了开发能力。同时对原生接口依赖性极强，不同平台要进行不同的开发。</li>
<li>其他的问题还有iOS6中JavaScriptCore、javascriptCore.framework为私有，使用上可能会受apple政策影响。</li>
</ol>
<p>总之，虽然现状并不完美，但是React Native已经让我们看到了无限的希望，它在未来必定会产生巨大的影响。</p>
<h2 id="参考">参考</h2><ol>
<li><a href="http://facebook.github.io/react/blog/2015/03/26/introducing-react-native.html" target="_blank" rel="external">Introducing React Native</a></li>
<li><a href="http://facebook.github.io/react/index.html" target="_blank" rel="external">React</a></li>
<li><a href="http://facebook.github.io/react-native/" target="_blank" rel="external">React Native</a></li>
<li><a href="http://www.zhihu.com/question/27852694" target="_blank" rel="external">如何评价 React Native？</a></li>
<li><a href="http://blog.devtang.com/blog/2015/02/01/talk-about-react-native/" target="_blank" rel="external">谈谈 React Native</a></li>
<li><a href="http://blog.cnbang.net/tech/2698/" target="_blank" rel="external">React Native通信机制详解</a></li>
<li><a href="http://www.hotobear.com/?p=1015" target="_blank" rel="external">React Native 初探（iOS）</a></li>
<li><a href="http://www.cocoachina.com/ios/20150408/11513.html" target="_blank" rel="external">深入浅出 React Native：使用 JavaScript 构建原生应用</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://7tt058.com1.z0.glb.clouddn.com/reactnative.png" alt="React Native"></p>
<p>Facebook在今年的React.js Conf 2015上推出了React Native，而这已经成为目前最热门的讨论话题。</p>
<p>我们知道，传统的原生开发是需要一定门槛的，要转行为原生开发其实是比较困难的。这就导致了市场需求大，而相关开发人员不能满足的问题。相比较而言，web开发的入门就比较容易，相关的开发者也就比较多。如果能让一部分web开发者直接开发原生应用，这将是多么美好的一件事情啊，而这也是不少框架出现的直接原因。</p>
<p>如果你本身是就是各个平台原生应用的开发者，那么React Native貌似不会给你带来更大的兴趣。但是，作为使用javascript的web开发人员，它的出现无疑是影响巨大的。React Native让web开发人员通过习惯的开发方式(使用React)来开发原生应用成为了可能，更重要的是它提出了一种新的开发理念，而这也是它目前火爆的主要原因。</p>
<p>既然是React Native，那么它必然与Native有着或多或少的关系。没错，React是React Native的强有力支撑，在React Native的实现中占有非常重要的作用，但是这基本属于另一个话题，本文不会着重介绍React、Flux等相关概念。</p>]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://reygreen1.github.io/tags/JavaScript/"/>
    
      <category term="React" scheme="http://reygreen1.github.io/tags/React/"/>
    
      <category term="移动端" scheme="http://reygreen1.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
      <category term="移动端开发" scheme="http://reygreen1.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hexo使用入门指导]]></title>
    <link href="http://reygreen1.github.io/2015/03/12/hello-world/"/>
    <id>http://reygreen1.github.io/2015/03/12/hello-world/</id>
    <published>2015-03-11T16:00:00.000Z</published>
    <updated>2015-04-15T10:53:35.000Z</updated>
    <content type="html"><![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick_Start">Quick Start</h2><h3 id="Create_a_new_post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    <summary type="html">
    <![CDATA[Hexo使用入门指导]]>
    
    </summary>
    
      <category term="hexo" scheme="http://reygreen1.github.io/tags/hexo/"/>
    
      <category term="随笔" scheme="http://reygreen1.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
