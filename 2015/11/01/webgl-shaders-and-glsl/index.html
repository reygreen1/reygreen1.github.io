<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  
  <title>[译]WebGL 基础系列：WebGL着色器和GLSL | Rey&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  
    <meta name="author" content="guorui">
  
  
    <meta name="description" content="原文地址：http://webglfundamentals.org/webgl/lessons/webgl-shaders-and-glsl.html


This is a continuation from WebGL Fundamentals.If you haven’t read about how WebGL works you might want to read this first">
  
  <meta name="description" content="原文地址：http://webglfundamentals.org/webgl/lessons/webgl-shaders-and-glsl.html


This is a continuation from WebGL Fundamentals.If you haven’t read about how WebGL works you might want to read this first">
<meta property="og:type" content="article">
<meta property="og:title" content="[译]WebGL 基础系列：WebGL着色器和GLSL">
<meta property="og:url" content="http://reygreen1.github.io/2015/11/01/webgl-shaders-and-glsl/index.html">
<meta property="og:site_name" content="Rey's Blog">
<meta property="og:description" content="原文地址：http://webglfundamentals.org/webgl/lessons/webgl-shaders-and-glsl.html


This is a continuation from WebGL Fundamentals.If you haven’t read about how WebGL works you might want to read this first">
<meta property="og:image" content="http://7tt058.com1.z0.glb.clouddn.com/pearl-boy.jpg">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="[译]WebGL 基础系列：WebGL着色器和GLSL">
<meta name="twitter:description" content="原文地址：http://webglfundamentals.org/webgl/lessons/webgl-shaders-and-glsl.html


This is a continuation from WebGL Fundamentals.If you haven’t read about how WebGL works you might want to read this first">
  
    <link rel="alternate" href="/atom.xml" title="Rey&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" type="image/x-icon" href="http://s0.qhimg.com/static/79ec3f5e5536f764/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
</head>

<body>
  <div class="wrapper">
    <header id="header">
  <div class="title">
    <h1><a href="/">Rey&#39;s Blog</a></h1>
    <p><a href="/">&lt;!-- A site to show something about myself --&gt;</a></p>
  </div>
  <nav class="nav">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
      
        <li><a href="/atom.xml">RSS</a></li>
      
    </ul>
    <div class="clearfix"></div>
  </nav>
  <div class="clearfix"></div>
</header>
    <div class="content"><article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2015/11/01/webgl-shaders-and-glsl/">
  <time datetime="2015-10-31T16:00:00.000Z">
    2015-11-01
  </time>
</a>
    
    
  
    <h1 class="title">[译]WebGL 基础系列：WebGL着色器和GLSL</h1>
  

  </header>
  
  <div class="entry">
    
      <p>原文地址：<a href="http://webglfundamentals.org/webgl/lessons/webgl-shaders-and-glsl.html" target="_blank" rel="external">http://webglfundamentals.org/webgl/lessons/webgl-shaders-and-glsl.html</a></p>
<p><img src="http://7tt058.com1.z0.glb.clouddn.com/pearl-boy.jpg" alt="Pearl Boy"></p>
<blockquote>
<p>This is a continuation from <a href="webgl-fundamentals.html">WebGL Fundamentals</a>.<br>If you haven’t read about how WebGL works you might want to <a href="webgl-how-it-works.html">read this first</a>.</p>
</blockquote>
<p>本章内容紧接<a href="http://webglfundamentals.org/webgl/lessons/webgl-fundamentals.html" target="_blank" rel="external">WebGL 基本原理</a>来进行介绍。如果你还不了解 WebGL 的工作机制，那么你可能需要先来读读这篇文章<a href="http://webglfundamentals.org/webgl/lessons/webgl-how-it-works.html" target="_blank" rel="external">WebGL 工作机制</a>。</p>
<blockquote>
<p>We’ve talked about shaders and GLSL but haven’t really given them any specific details.<br>I think I was hoping it would be clear by example but let’s try to make it clearer just in case.</p>
</blockquote>
<p>在前面的几篇文章中，我们已经提到了着色器和 GLSL 的相关知识，但是并没有对它们进行更多的解释和详细说明。我一直认为举例来介绍相关概念可以让你更容易接受，但是为了让你有更清晰的认识，我准备在这里对它们做更加详细的说明。</p>
<blockquote>
<p>As mentioned in <a href="webgl-how-it-works.html">how it works</a> WebGL requires 2 shaders every time you<br>draw something. A <em>vertex shader</em> and a <em>fragment shader</em>. Each shader is a <em>function</em>. A vertex<br>shader and fragment shader are linked together into a shader program (or just program). A typical<br>WebGL app will have many shader programs.</p>
</blockquote>
<p>正如在<a href="http://webglfundamentals.org/webgl/lessons/webgl-how-it-works.html" target="_blank" rel="external">WebGL 工作机制</a>中提到的那样，当我们需要绘制图形的时候，WebGL 需要使用2种着色器：<em>顶点着色器</em>和<em>片元着色器</em>。着色器就是一个<em>函数方法</em>。顶点着色器和片元着色器在着色器程序（或者程序）中被连接到一起。一个典型的 WebGL 应用包含多个着色器程序。</p>
<blockquote>
<p>译者注：这里的着色器程序应该是指 shader program 对象。program 对象有且仅有一个顶点着色器对象和一个片元着色器对象连接到它。链接 program 对象后，可以产生最终的可执行程序，它包含最后可以在硬件上执行的硬件指令。</p>
</blockquote>
<a id="more"></a>
<blockquote>
<h2 id="Vertex_Shader">Vertex Shader</h2></blockquote>
<h2 id="顶点着色器">顶点着色器</h2><blockquote>
<p>A Vertex Shader’s job is to generate clipspace coordinates. It always takes the form</p>
</blockquote>
<p>顶点着色器的工作是用来生成空间位置坐标。它一般像下面这样来使用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">   gl_Position = doMathToMakeClipspaceCoordinates</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Your shader is called once per vertex. Each time it’s called you are required to set the<br>the special global variable, <code>gl_Position</code> to some clipspace coordinates.</p>
</blockquote>
<p>每个顶点都会调用一次着色器。当它每次被调用的时候，你需要将一些空间坐标设置给一个特殊的全局变量 <code>gl_Position</code>。</p>
<blockquote>
<p>Vertex shaders need data. They can get that data in 3 ways.</p>
<ol>
<li><a href="#attributes">Attributes</a> (data pulled from buffers)</li>
<li><a href="#uniforms">Uniforms</a> (values that stay the same during for all vertices of a single draw call)</li>
<li><a href="#textures-in-vertex-shaders">Textures</a> (data from pixels/texels)</li>
</ol>
</blockquote>
<p>顶点着色器需要一些必须的数据，它们一般有3种获取方式。</p>
<ol>
<li><a href="#attributes">Attribute</a> (从缓冲区对象中拉取数据)</li>
<li><a href="#uniforms">Uniform</a> (在绘制过程中所有顶点都需要的、固定的数据值)</li>
<li><a href="#textures-in-vertex-shaders">Texture</a> (像素/纹理元素数据)</li>
</ol>
<blockquote>
<h3 id="Attributes">Attributes</h3></blockquote>
<h3 id="Attribute">Attribute</h3><blockquote>
<p>The most common way is through buffers and <em>attributes</em>.<br><a href="webgl-how-it-works.html">How it works</a> covered buffers and<br>attributes. You create buffers,</p>
</blockquote>
<p>给顶点着色器传递数据，最常用的方式是通过缓冲区对象和 <em>attribute</em>。<a href="http://webglfundamentals.org/webgl/lessons/webgl-how-it-works.html" target="_blank" rel="external">工作机制</a>中已经介绍了缓冲区对象和 attribute 相关内容。我们可以像下面这样来创建缓冲区对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buf = gl.createBuffer();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>put data in those buffers</p>
</blockquote>
<p>将数据放入缓冲区对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gl.bindBuffer(gl.ARRAY_BUFFER, buf);</span><br><span class="line">gl.bufferData(gl.ARRAY_BUFFER, someData, gl.STATIC_DRAW);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Then, given a shader program you made you look up the location of its attributes,</p>
</blockquote>
<p>然后，获取 attribute 变量的地址：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> positionLoc = gl.getAttribLocation(someShaderProgram, <span class="string">"a_position"</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>then tell WebGL how to pull data out of those buffers and into the attribute</p>
</blockquote>
<p>然后，告诉 WebGL 如何从缓冲区对象中获取数据，并把这些数据放入 attribute 变量中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从缓冲区对象中获取数据并传递给这个 attribute 变量</span></span><br><span class="line">gl.enableVertexAttribArray(positionLoc);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> numComponents = <span class="number">3</span>;  <span class="comment">// (x, y, z)</span></span><br><span class="line"><span class="keyword">var</span> type = gl.FLOAT;</span><br><span class="line"><span class="keyword">var</span> normalize = <span class="literal">false</span>;  <span class="comment">// 保持值不变</span></span><br><span class="line"><span class="keyword">var</span> offset = <span class="number">0</span>;         <span class="comment">// 从缓冲区起始位置开始</span></span><br><span class="line"><span class="keyword">var</span> stride = <span class="number">0</span>;         <span class="comment">// 到下一个顶点需要移动的字节数</span></span><br><span class="line">                        <span class="comment">// 0表示使用符合类型大小的 stride</span></span><br><span class="line"></span><br><span class="line">gl.vertexAttribPointer(positionLoc, numComponents, type, <span class="literal">false</span>, stride, offset);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>In <a href="webgl-fundamentals.html">WebGL fundamentals</a> we showed that we can do no math<br>in the shader and just pass the data directly through.</p>
</blockquote>
<p>我们已经在<a href="http://webglfundamentals.org/webgl/lessons/webgl-fundamentals.html" target="_blank" rel="external">WebGL 基本原理</a>中说明，在着色器中不做数学运算，只是直接传递数据值而已：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">attribute vec4 a_position;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">   gl_Position = a_position;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>If we put clipspace vertices into our buffers it will work.</p>
</blockquote>
<p>当我们将空间坐标数据放入缓冲区对象时，程序就正常运行了。</p>
<blockquote>
<p>Attributes can use <code>float</code>, <code>vec2</code>, <code>vec3</code>, <code>vec4</code>, <code>mat2</code>, <code>mat3</code>, and <code>mat4</code> as types.</p>
</blockquote>
<p>attribute 变量可以使用的数据类型有：<code>float</code>、<code>vec2</code>、<code>vec3</code>、<code>vec4</code>、<code>mat2</code>、<code>mat3</code> 和 <code>mat4</code>。</p>
<blockquote>
<h3 id="Uniforms">Uniforms</h3></blockquote>
<h3 id="Uniform">Uniform</h3><blockquote>
<p>For a vertex shader uniforms are values passed to the vertex shader that stay the same<br>for all vertices in a draw call. As a very simple example we could add an offset to<br>the vertex shader above</p>
</blockquote>
<p>对于顶点着色器而言，uniform 变量用来存储那些在绘制过程中所有顶点都共用的数据值。举个简单的例子，我们给上文的顶点着色器添加一个 offset 参数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">attribute vec4 a_position;</span><br><span class="line">uniform vec4 u_offset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">   gl_Position = a_position + u_offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>And now we could offset every vertex by a certain amount. First we’d look up the<br>location of the uniform</p>
</blockquote>
<p>现在我们可以给每个顶点都设置一个具体的偏移量了。首先，我们来获取下 uniform 变量的地址：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> offsetLoc = gl.getUniformLocation(someProgram, <span class="string">"u_offset"</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>And then before drawing we’d set the uniform</p>
</blockquote>
<p>然后，在绘制前我们需要先设置下 uniform 变量的值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gl.uniform4fv(offsetLoc, [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]);  <span class="comment">// 将它移动到视图的右半边</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Uniforms can be many types. For each type you have to call the corresponding function to set it.</p>
</blockquote>
<p>uniform 变量有多种类型。对于不同的类型，你只有调用正确的方法才可以设置变量值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">gl.uniform1f (floatUniformLoc, v);                 <span class="comment">// for float</span></span><br><span class="line">gl.uniform1fv(floatUniformLoc, [v]);               <span class="comment">// for float or float array</span></span><br><span class="line">gl.uniform2f (vec2UniformLoc,  v0, v1);            <span class="comment">// for vec2</span></span><br><span class="line">gl.uniform2fv(vec2UniformLoc,  [v0, v1]);          <span class="comment">// for vec2 or vec2 array</span></span><br><span class="line">gl.uniform3f (vec3UniformLoc,  v0, v1, v2);        <span class="comment">// for vec3</span></span><br><span class="line">gl.uniform3fv(vec3UniformLoc,  [v0, v1, v2]);      <span class="comment">// for vec3 or vec3 array</span></span><br><span class="line">gl.uniform4f (vec4UniformLoc,  v0, v1, v2, v4);    <span class="comment">// for vec4</span></span><br><span class="line">gl.uniform4fv(vec4UniformLoc,  [v0, v1, v2, v4]);  <span class="comment">// for vec4 or vec4 array</span></span><br><span class="line"></span><br><span class="line">gl.uniformMatrix2fv(mat2UniformLoc, <span class="literal">false</span>, [  <span class="number">4</span>x element array ])  <span class="comment">// for mat2 or mat2 array</span></span><br><span class="line">gl.uniformMatrix3fv(mat3UniformLoc, <span class="literal">false</span>, [  <span class="number">9</span>x element array ])  <span class="comment">// for mat3 or mat3 array</span></span><br><span class="line">gl.uniformMatrix4fv(mat4UniformLoc, <span class="literal">false</span>, [ <span class="number">16</span>x element array ])  <span class="comment">// for mat4 or mat4 array</span></span><br><span class="line"></span><br><span class="line">gl.uniform1i (intUniformLoc,   v);                 <span class="comment">// for int</span></span><br><span class="line">gl.uniform1iv(intUniformLoc, [v]);                 <span class="comment">// for int or int array</span></span><br><span class="line">gl.uniform2i (ivec2UniformLoc, v0, v1);            <span class="comment">// for ivec2</span></span><br><span class="line">gl.uniform2iv(ivec2UniformLoc, [v0, v1]);          <span class="comment">// for ivec2 or ivec2 array</span></span><br><span class="line">gl.uniform3i (ivec3UniformLoc, v0, v1, v2);        <span class="comment">// for ivec3</span></span><br><span class="line">gl.uniform3iv(ivec3UniformLoc, [v0, v1, v2]);      <span class="comment">// for ivec3 or ivec3 array</span></span><br><span class="line">gl.uniform4i (ivec4UniformLoc, v0, v1, v2, v4);    <span class="comment">// for ivec4</span></span><br><span class="line">gl.uniform4iv(ivec4UniformLoc, [v0, v1, v2, v4]);  <span class="comment">// for ivec4 or ivec4 array</span></span><br><span class="line"></span><br><span class="line">gl.uniform1i (sampler2DUniformLoc,   v);           <span class="comment">// for sampler2D (textures)</span></span><br><span class="line">gl.uniform1iv(sampler2DUniformLoc, [v]);           <span class="comment">// for sampler2D or sampler2D array</span></span><br><span class="line"></span><br><span class="line">gl.uniform1i (samplerCubeUniformLoc,   v);         <span class="comment">// for samplerCube (textures)</span></span><br><span class="line">gl.uniform1iv(samplerCubeUniformLoc, [v]);         <span class="comment">// for samplerCube or samplerCube array</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>There’s also types <code>bool</code>, <code>bvec2</code>, <code>bvec3</code>, and <code>bvec4</code>. They use either the <code>gl.uniform?f?</code> or <code>gl.uniform?i?</code><br>functions.</p>
</blockquote>
<p>其它的还有<code>bool</code>、<code>bvec2</code>、<code>bvec3</code> 和 <code>bvec4</code> 的数据类型。它们可以使用形如 <code>gl.uniform?f?</code> 或 <code>gl.uniform?i?</code> 的方法即可。</p>
<blockquote>
<p>Note that for an array you can set all the uniforms of the array at once. For example</p>
</blockquote>
<p>注意，你可以使用数组一次性给 uniform 数组形式的变量赋值。举例如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in shader</span></span><br><span class="line">uniform vec2 u_someVec2[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// in JavaScript at init time</span></span><br><span class="line"><span class="keyword">var</span> someVec2Loc = gl.getUniformLocation(someProgram, <span class="string">"u_someVec2"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// at render time</span></span><br><span class="line">gl.uniform2fv(someVec2Loc, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]);  <span class="comment">// set the entire array of u_someVec3</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>But if you want to set individual elements of the array you must look up the location of<br>each element individually.</p>
</blockquote>
<p>但是，如果你想要单独设置数组中的元素值，那你必须要单独查询每一个元素的地址。然后，再针对每一个元素分别赋值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in JavaScript at init time</span></span><br><span class="line"><span class="keyword">var</span> someVec2Element0Loc = gl.getUniformLocation(someProgram, <span class="string">"u_someVec2[0]"</span>);</span><br><span class="line"><span class="keyword">var</span> someVec2Element1Loc = gl.getUniformLocation(someProgram, <span class="string">"u_someVec2[1]"</span>);</span><br><span class="line"><span class="keyword">var</span> someVec2Element2Loc = gl.getUniformLocation(someProgram, <span class="string">"u_someVec2[2]"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// at render time</span></span><br><span class="line">gl.uniform2fv(someVec2Element0Loc, [<span class="number">1</span>, <span class="number">2</span>]);  <span class="comment">// set element 0</span></span><br><span class="line">gl.uniform2fv(someVec2Element1Loc, [<span class="number">3</span>, <span class="number">4</span>]);  <span class="comment">// set element 1</span></span><br><span class="line">gl.uniform2fv(someVec2Element2Loc, [<span class="number">5</span>, <span class="number">6</span>]);  <span class="comment">// set element 2</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Similarly if you create a struct</p>
</blockquote>
<p>类似的，如果你要创建一个结构体：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct SomeStruct &#123;</span><br><span class="line">  bool active;</span><br><span class="line">  vec2 someVec2;</span><br><span class="line">&#125;;</span><br><span class="line">uniform SomeStruct u_someThing;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>you have to look up each field individually</p>
</blockquote>
<p>你需要单独去获取每一个属性的地址：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someThingActiveLoc = gl.getUniformLocation(someProgram, <span class="string">"u_someThing.active"</span>);</span><br><span class="line"><span class="keyword">var</span> someThingSomeVec2Loc = gl.getUniformLocation(someProgram, <span class="string">"u_someThing.someVec2"</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<h3 id="Textures_in_Vertex_Shaders">Textures in Vertex Shaders</h3></blockquote>
<h3 id="顶点着色器中的纹理（texture）">顶点着色器中的纹理（texture）</h3><blockquote>
<p>See <a href="#textures-in-fragment-shaders">Textures in Fragment Shaders</a>.</p>
</blockquote>
<p>可参考<a href="http://webglfundamentals.org/webgl/lessons/webgl-shaders-and-glsl.html#textures-in-fragment-shaders" target="_blank" rel="external">片元着色器中的纹理</a>。</p>
<blockquote>
<h2 id="Fragment_Shader">Fragment Shader</h2></blockquote>
<h2 id="片元着色器">片元着色器</h2><blockquote>
<p>A Fragment Shader’s job is to provide a color for the current pixel being rasterized.<br>It always takes the form</p>
</blockquote>
<p>片元着色器的工作主要是为当前进行光栅化的像素提供颜色值。它一般如下面这样的形式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">precision mediump float;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">   gl_FragColor = doMathToMakeAColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Your fragment shader is called once per pixel. Each time it’s called you are required<br>to set the special global variable, <code>gl_FragColor</code> to some color.</p>
</blockquote>
<p>每个像素都会调用一次片元着色器。每当它被调用的时候，你都需要给一个特殊的全局变量 <code>gl_FragColor</code> 设置颜色值。</p>
<blockquote>
<p>Fragment shaders need data. They can get data in 3 ways</p>
</blockquote>
<p>片元着色器也需要数据，它们通常有3种获取方式：</p>
<blockquote>
<ol>
<li><a href="#uniforms">Uniforms</a> (values that stay the same for every pixel of a single draw call)</li>
<li><a href="#textures-in-fragment-shaders">Textures</a> (data from pixels/texels)</li>
<li><a href="#varyings">Varyings</a> (data passed from the vertex shader and interpolated)</li>
</ol>
</blockquote>
<ol>
<li><a href="#uniforms">Uniform</a> (在绘制过程中每个像素都需要的、固定的变量值)</li>
<li><a href="#textures-in-fragment-shaders">Texture</a> (像素/纹理元素数据)</li>
<li><a href="#varyings">Varying</a> (从顶点着色器传递过来并且经过内插过程的数据)</li>
</ol>
<blockquote>
<h3 id="Uniforms_in_Fragment_Shaders">Uniforms in Fragment Shaders</h3></blockquote>
<h3 id="片元着色器中的_uniform_变量">片元着色器中的 uniform 变量</h3><blockquote>
<p>See <a href="#uniforms">Uniforms in Vertex Shaders</a>.</p>
</blockquote>
<p>可参考上文顶点着色器中关于 uniform 变量的介绍。</p>
<blockquote>
<h3 id="Textures_in_Fragment_Shaders">Textures in Fragment Shaders</h3></blockquote>
<h3 id="片元着色器中的纹理">片元着色器中的纹理</h3><blockquote>
<p>Getting a value from a texture in a shader we create a <code>sampler2D</code> uniform and use the GLSL<br>function <code>texture2D</code> to extract a value from it.</p>
</blockquote>
<p>为了从纹理中获取数据，我们需要创建一个 uniform 类型的 <code>sampler2D</code> 变量，然后使用 GLSL 中的 <code>texture2D</code> 方法来导出数据。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">precision mediump float;</span><br><span class="line"></span><br><span class="line">uniform sampler2D u_texture;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">   vec2 texcoord = vec2(<span class="number">0.5</span>, <span class="number">0.5</span>)  <span class="comment">// get a value from the middle of the texture</span></span><br><span class="line">   gl_FragColor = texture2D(u_texture, texcoord);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>What data comes out of the texture is <a href="webgl-3d-textures.html">dependent on many settings</a>.<br>At a minimum we need to create and put data in the texture, for example</p>
</blockquote>
<p>纹理会导出什么样的数据呢？这<a href="http://webglfundamentals.org/webgl/lessons/webgl-3d-textures.html" target="_blank" rel="external">依赖于很多配置项</a>。<br>我们至少要创建纹理并把数据传递过来，如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tex = gl.createTexture();</span><br><span class="line">gl.bindTexture(gl.TEXTURE_2D, tex);</span><br><span class="line"><span class="keyword">var</span> level = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> width = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> height = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> data = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>, <span class="number">255</span>]);</span><br><span class="line">gl.texImage2D(gl.TEXTURE_2D, level, gl.RGBA, width, height, <span class="number">0</span>, gl.RGBA, gl.UNSIGNED_BYTE, data);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Then look up the uniform location in the shader program</p>
</blockquote>
<p>然后，获取 uniform 变量的地址：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someSamplerLoc = gl.getUniformLocation(someProgram, <span class="string">"u_texture"</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>WebGL then requires you to bind it to a texture unit</p>
</blockquote>
<p>然后，我们需要将它绑定到一个纹理单元：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> unit = <span class="number">5</span>;  <span class="comment">// Pick some texture unit</span></span><br><span class="line">gl.activeTexture(gl.TEXTURE0 + unit);</span><br><span class="line">gl.bindTexture(gl.TEXTURE_2D, tex);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>And tell the shader which unit you bound the texture to</p>
</blockquote>
<p>并且要告诉着色器你刚才绑定的纹理单元：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gl.uniform1i(someSamplerLoc, unit);</span><br></pre></td></tr></table></figure>
<blockquote>
<h3 id="Varyings">Varyings</h3></blockquote>
<h3 id="varying">varying</h3><blockquote>
<p>A varying is a way to pass a value from a vertex shader to a fragment shader which we<br>covered in <a href="webgl-how-it-works.html">how it works</a>.</p>
</blockquote>
<p>我们已经在<a href="http://webglfundamentals.org/webgl/lessons/webgl-how-it-works.html" target="_blank" rel="external">WebGL 工作机制</a>中介绍过了，varying 变量主要用来从顶点着色器向片元着色器传递数值。</p>
<blockquote>
<p>To use a varying we need to declare matching varyings in both a vertex and fragment shader.<br>We set the varying in the vertex shader with some value per vertex. When WebGL draws pixels<br>it will interpolate between those values and pass them to the corresponding varying in<br>the fragment shader</p>
</blockquote>
<p>为了使用它，我们需要在顶点着色器和片元着色器中声明同名的 varying 变量。在顶点着色器中，我们根据每个顶点来设置 varying 变量值。当 WebGL 绘制像素的时候，它会对这些 varying 变量值执行内插过程，然后把处理后得到的相关值传递给片元着色器中的同名 varying 变量。</p>
<blockquote>
<p>Vertex shader</p>
</blockquote>
<p>顶点着色器</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">attribute vec4 a_position;</span><br><span class="line"></span><br><span class="line">uniform vec4 u_offset;</span><br><span class="line"></span><br><span class="line">varying vec4 v_positionWithOffset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  gl_Position = a_position + u_offset;</span><br><span class="line">  v_positionWithOffset = a_position + u_offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Fragment shader</p>
</blockquote>
<p>片元着色器</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">precision mediump float;</span><br><span class="line"></span><br><span class="line">varying vec4 v_positionWithOffset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="comment">// convert from clipsapce (-1 &lt;-&gt; +1) to color space (0 -&gt; 1).</span></span><br><span class="line">  vec4 color = v_positionWithOffset * <span class="number">0.5</span> + <span class="number">0.5</span></span><br><span class="line">  gl_FragColor = color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>The example above is a mostly nonsense example. It doesn’t generally make sense to<br>directly copy the clipspace values to the fragment shader and use them as colors. Nevertheless<br>it will work and produce colors.</p>
</blockquote>
<p>上面的例子并不太明智。直接将空间坐标值传递给片元着色器并用作颜色值看起来是非常不合理的做法。然而，这确实能让程序运行起来，并渲染出了颜色。</p>
<h2 id="GLSL">GLSL</h2><blockquote>
<p>GLSL stands for Graphics Library Shader Language. It’s the language shaders are written<br>in. It has some special semi unique features that are certainly not common in JavaScript.<br>It’s designed to do the math that is commonly needed to compute things for rasterizing<br>graphics. So for example it has built in types like <code>vec2</code>, <code>vec3</code>, and <code>vec4</code> which<br>represent 2 values, 3 values, and 4 values respectively. Similarly it has <code>mat2</code>, <code>mat3</code><br>and <code>mat4</code> which represent 2x2, 3x3, and 4x4 matrices. You can do things like multiply<br>a <code>vec</code> by a scalar.</p>
</blockquote>
<p>GLSL 的全称为 Graphics Library Shader Language。它是编写着色器的编程语言。在 GLSL 中，有很多特性与 JavaScript 有很大区别。GLSL 在设计的时候，主要是想用它来解决图形光栅化过程中的数学运算的。因此，你在例子中可以看到分别携带了2个、3个甚至4个值的<code>vec2</code>、<code>vec3</code>和<code>vec4</code>的数据类型。同样，它还有<code>mat2</code>、<code>mat3</code>和<code>mat4</code>的类型，分别表示2x2、3x3和4x4的矩阵。你甚至可以方便的对一个<code>vec</code>和一个标量做乘法计算。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vec4 a = vec4(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">vec4 b = a * <span class="number">2.0</span>;</span><br><span class="line"><span class="comment">// b is now vec4(2, 4, 6, 8);</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Similarly it can do matrix multiplication and vector to matrix multiplication</p>
</blockquote>
<p>同样的，它也可以做矩阵和矩阵、矢量和矩阵的乘法运算</p>
<blockquote>
<p>译者注：原文例子中，a、b、v 的值均已丢失，没办法知道具体值了，大家只要理解是矩阵和向量即可。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mat4 a = ???</span><br><span class="line">mat4 b = ???</span><br><span class="line">mat4 c = a * b;</span><br><span class="line"></span><br><span class="line">vec4 v = ???</span><br><span class="line">vec4 y = c * v;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>It also has various selectors for the parts of a vec. For a vec4</p>
</blockquote>
<p>它也包含了很多选择器，让你可以方便的选取矢量部分维度上的值。例如定义一个 vec4</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vec4 v;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><code>v.x</code> is the same as <code>v.s</code> and <code>v.r</code> and <code>v[0]</code>.</li>
<li><code>v.y</code> is the same as <code>v.t</code> and <code>v.g</code> and <code>v[1]</code>.</li>
<li><code>v.z</code> is the same as <code>v.p</code> and <code>v.b</code> and <code>v[2]</code>.</li>
<li><code>v.w</code> is the same as <code>v.q</code> and <code>v.a</code> and <code>v[3]</code>.</li>
</ul>
</blockquote>
<ul>
<li><code>v.x</code> 得到的值同 <code>v.s</code>、<code>v.r</code>和<code>v[0]</code>得到的值是完全一样的。</li>
<li><code>v.y</code> 得到的值同 <code>v.t</code>、<code>v.g</code>和<code>v[1]</code>得到的值是完全一样的。</li>
<li><code>v.z</code> 得到的值同 <code>v.p</code>、<code>v.b</code>和<code>v[2]</code>得到的值是完全一样的。</li>
<li><code>v.w</code> 得到的值同 <code>v.q</code>、<code>v.a</code>和<code>v[3]</code>得到的值是完全一样的。</li>
</ul>
<blockquote>
<p>译者注：因为矢量可以用来存储顶点的坐标、颜色和纹理坐标，所以 GLSL ES 支持以上三种分量名称，从而增加程序可读性。</p>
<p>It it able to <em>swizzle</em> vec components which means you can swap or repeat components.</p>
</blockquote>
<p>你还可以通过对矢量同时抽取多个分量，从而实现 <em>混合</em> 的过程。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.yyyy</span><br></pre></td></tr></table></figure>
<blockquote>
<p>is the same as</p>
</blockquote>
<p>它等价于下面这种形式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vec4(v.y, v.y, v.y, v.y)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Similarly</p>
</blockquote>
<p>同样可以使用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.bgra</span><br></pre></td></tr></table></figure>
<blockquote>
<p>is the same as</p>
</blockquote>
<p>或者这种</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vec4(v.b, v.g, v.r, v.a)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>when constructing a vec or a mat you can supply multiple parts at once. So for example</p>
</blockquote>
<p>当构造矢量或者矩阵的时候，你也可以一次性提供多个部分来完成构造。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vec4(v.rgb, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Is the same as</p>
</blockquote>
<p>等价于</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vec4(v.r, v.g, v.b, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>One thing you’ll likely get caught up on is that GLSL is very type strict.</p>
</blockquote>
<p>编程中时刻要注意 GLSL 是一种强类型语言，不然极易导致程序报错。如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float f = <span class="number">1</span>;  <span class="comment">// ERROR 1 is an int. You can't assign an int to a float</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>The correct way is one of these</p>
</blockquote>
<p>正确的方法是像下面这么写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float f = <span class="number">1.0</span>;      <span class="comment">// 使用 float</span></span><br><span class="line">float f = float(<span class="number">1</span>)  <span class="comment">// 把 integer 转换为 float</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>The example above of <code>vec4(v.rgb, 1)</code> doesn’t complain about the <code>1</code> because <code>vec4</code> is<br>casting the things inside just like <code>float(1)</code>.</p>
</blockquote>
<p>在上面 <code>vec4(v.rgb, 1)</code> 的例子中也使用了 <code>1</code>，但是它并没有报错。这是为什么呢？因为 <code>vec4</code> 在内部已经对这些参数做了类似 <code>float(1)</code> 的转换操作。</p>
<blockquote>
<p>GLSL has a bunch of built in functions. Many of them operate on multiple components at once.<br>So for example</p>
</blockquote>
<p>GLSL 包含了很多内置功能函数。其中很多函数操作都是一次操作多个分量。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T sin(T angle)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Means T can be <code>float</code>, <code>vec2</code>, <code>vec3</code> or <code>vec4</code>. If you pass in <code>vec4</code> you get <code>vec4</code> back<br>which the sine of each of the components. In other words if <code>v</code> is a <code>vec4</code> then</p>
</blockquote>
<p>T 可以使用 <code>float</code>、<code>vec2</code>、<code>vec3</code> 或者 <code>vec4</code> 的类型。如果你传给函数的参数为 <code>vec4</code> 类型，那么你得到的操作结果就是一个在每个分量上执行了 sin 操作的 <code>vec4</code>。换句话说，假设 <code>v</code> 是 <code>vec4</code> 类型，那么</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vec4 s = sin(v);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>is the same as</p>
</blockquote>
<p>得到的结果同下面的操作是一样的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vec4 s = vec4(sin(v.x), sin(v.y), sin(v.z), sin(v.w));</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Sometimes one argument is a float and the rest is <code>T</code>. That means that float will be applied<br>to all the components. For example if <code>v1</code> and <code>v2</code> are <code>vec4</code> and <code>f</code> is a float then</p>
</blockquote>
<p>有些时候，可能一个参数是 float 类型，其他部分的参数为 <code>T</code> 类型。那么时候，float 类型的参数会参与各个分量的计算。例如，假设 <code>v1</code> 和 <code>v2</code> 都是 <code>vec4</code> 类型，而 <code>f</code> 是 float 类型，然后执行下面的操作：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vec4 m = mix(v1, v2, f);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>is the same as</p>
</blockquote>
<p>操作结果同下面的形式是等价的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vec4 m = vec4(</span><br><span class="line">  mix(v1.x, v2.x, f),</span><br><span class="line">  mix(v1.y, v2.y, f),</span><br><span class="line">  mix(v1.z, v2.z, f),</span><br><span class="line">  mix(v1.w, v2.w, f));</span><br></pre></td></tr></table></figure>
<blockquote>
<p>You can see a list of all the GLSL functions on the last page of <a href="https://www.khronos.org/files/webgl/webgl-reference-card-1_0.pdf" target="_blank" rel="external">the WebGL<br>Reference Card</a>.<br>If you like really dry and verbose stuff you can try<br><a href="https://www.khronos.org/files/opengles_shading_language.pdf" target="_blank" rel="external">the GLSL spec</a>.</p>
</blockquote>
<p>你可以在<a href="https://www.khronos.org/files/webgl/webgl-reference-card-1_0.pdf" target="_blank" rel="external">the WebGL<br>Reference Card</a>中查看 GLSL 的全部函数列表。如果喜欢更详细的介绍，那你可以参考<a href="https://www.khronos.org/files/opengles_shading_language.pdf" target="_blank" rel="external">the GLSL spec</a>。</p>
<blockquote>
<h2 id="Putting_it_all_togehter">Putting it all togehter</h2></blockquote>
<h2 id="总结一下">总结一下</h2><blockquote>
<p>That’s the point of this entire series of posts. WebGL is all about creating various shaders, supplying<br>the data to those shaders and then calling <code>gl.drawArrays</code> or <code>gl.drawElements</code> to have WebGL process<br>the vertices by calling the current vertex shader for each vertex and then render pixels by calling the<br>the current fragment shader for each pixel.</p>
</blockquote>
<p>这里介绍的内容是整个系列文章中的重点内容。其实，WebGL 可以总结如下：创建各种着色器，给着色器提供数据，然后调用 <code>gl.drawArrays</code> 或者 <code>gl.drawElements</code> 方法来让 WebGL 处理器根据顶点着色器对每个顶点进行处理，最后使用片元着色器对每个像素进行渲染。</p>
<blockquote>
<p>Actually creating the shaders requires several lines of code. Since those lines are the same in<br>most WebGL programs and since once written you can pretty much ignore them <a href="webgl-boilerplate.html">how to compile GLSL shaders<br>and link them into a shader program is covered here</a>.</p>
</blockquote>
<p>实际上，创建着色器需要大量代码。然而，在大多数 WebGL 程序中这些代码都是相同的。因此，这些代码介绍一次就可以了，后续学习你可以完全忽略它们了。更多内容可以参考<a href="http://webglfundamentals.org/webgl/lessons/webgl-boilerplate.html" target="_blank" rel="external">how to compile GLSL shaders<br>and link them into a shader program is covered here</a>。</p>
<blockquote>
<p>If you’re just starting from here you can go in 2 directions. If you are interested in image procesing<br>I’ll show you <a href="webgl-image-processing.html">how to do some 2D image processing</a>.<br>If you are interesting in learning about translation,<br>rotation and scale then <a href="webgl-2d-translation.html">start here</a>.</p>
</blockquote>
<p>从这里开始，你有两个方向可以去深入学习。如果对图像处理感兴趣，你可以去学习<a href="http://webglfundamentals.org/webgl/lessons/webgl-image-processing.html" target="_blank" rel="external">how to do some 2D image processing</a>。如果对变换、旋转和缩放感兴趣，那么你可以去<a href="http://webglfundamentals.org/webgl/lessons/webgl-2d-translation.html" target="_blank" rel="external">这里</a>学习。</p>

    
  </div>
  <footer>
    
      
  <div class="categories">
    <a class="categories-link" href="/categories/webgl/">webgl</a>
  </div>

      
  <div class="tags">
    <a class="tags-link" href="/tags/webgl/">webgl</a>
  </div>

    
    <div class="clearfix"></div>
  </footer>
</article>


<section id="comment">
  	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="2015/11/01/webgl-shaders-and-glsl/" data-title="[译]WebGL 基础系列：WebGL着色器和GLSL" data-url="http://reygreen1.github.io/2015/11/01/webgl-shaders-and-glsl/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"curry2015"};
		(function() {
			var ds = document.createElement('script');
			ds.type = 'text/javascript';ds.async = true;
			ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
			ds.charset = 'UTF-8';
			(document.getElementsByTagName('head')[0] 
			 || document.getElementsByTagName('body')[0]).appendChild(ds);
		})();
		</script>
	<!-- 多说公共JS代码 end -->
</section>
</div>
  </div>
  <footer id="footer"><div class="copyright">
  
  &copy; 2015 <a href="/">guorui</a>
  
</div>
<div class="theme-copyright">
  Theme by <a href="https://github.com/orderedlist" target="_blank">orderedlist</a>
   | 
  Redesign by <a href="http://heroicyang.com/" target="_blank">Heroic Yang</a>
  
   |
  Modified by <a href="/">guorui</a>
  
</div>
<div class="clearfix"></div></footer>
  <script src="http://s7.qhimg.com/lib/jquery/1102.js"></script>
<script src="/js/scale.fix.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>


<script type="text/javascript">
  var duoshuoQuery = { short_name: 'curry2015' };
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';
    ds.async = true;
    ds.src = 'http://static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script>



<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
  (function($){
    $('.fancybox').fancybox();
  })(jQuery);
</script>

</body>
</html>